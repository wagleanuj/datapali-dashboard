{"ast":null,"code":"var _jsxFileName = \"/Users/anujwagle/Desktop/temp/datapali-dashboard/src/components/section.tsx\";\nimport { ButtonGroup } from \"@blueprintjs/core\";\nimport { QuestionSection } from \"./SurveyForm\";\nimport { QAQuestion } from \"../form/question\";\nimport React from \"react\";\nimport { QuestionButton } from \"./questionButton\";\nimport { DPFormItem } from \"./DPFormItem\";\nimport { SectionButton } from \"./sectionButton\";\nimport { DuplicateSettings } from \"./duplicateSettings\";\nexport class SectionC extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n\n  handleQuestionChange(q, path) {\n    if (this.props.handleQuestionChange) this.props.handleQuestionChange(q, path);\n  }\n\n  handleDuplicatingSettingsSave(id, dupe) {\n    if (this.props.handleSectionDuplicatingSettingsChange) this.props.handleSectionDuplicatingSettingsChange(id, dupe);\n  }\n\n  handleDuplicatingSettingsCancel() {}\n\n  render() {\n    let comp = null;\n    let readablePath = getReadablePath(this.props.parentPath);\n    if (readablePath) readablePath += \".\";\n    comp = this.props.section.content.map((item, index) => {\n      let childPath = this.props.parentPath.concat(index);\n\n      if (item instanceof QAQuestion) {\n        return React.createElement(QuestionButton, {\n          path: childPath,\n          questionId: item.id,\n          handleDeletion: this.props.handleDeleteChildSectionOrQuestion,\n          readablePath: readablePath + (index + 1),\n          key: item.id,\n          isExpanded: false,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 45\n          },\n          __self: this\n        }, React.createElement(DPFormItem, {\n          onChange: q => this.handleQuestionChange(q, childPath),\n          question: item,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 46\n          },\n          __self: this\n        }));\n      } else if (item instanceof QuestionSection) {\n        return React.createElement(SectionButton, {\n          path: childPath,\n          handleDeletion: this.props.handleDeleteChildSectionOrQuestion,\n          sectionId: item.id,\n          readablePath: readablePath + (index + 1),\n          key: item.id,\n          onClick: this.props.handleSectionClick,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 50\n          },\n          __self: this\n        }, React.createElement(DuplicateSettings, Object.assign({\n          definedQuestions: this.props.definedQuestions,\n          handleSave: d => this.handleDuplicatingSettingsSave(item.id, d),\n          handleCancel: this.handleDuplicatingSettingsCancel.bind(this)\n        }, item.duplicatingSettings, {\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 51\n          },\n          __self: this\n        })));\n      }\n\n      return null;\n    });\n    return React.createElement(ButtonGroup, {\n      fill: true,\n      vertical: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 57\n      },\n      __self: this\n    }, comp);\n  }\n\n}\nexport function getReadablePath(nu) {\n  return nu.slice(1).map(item => item + 1).join(\".\");\n}\n\nclass RootSection {\n  constructor() {\n    this.questions = {};\n    this.sections = {};\n    this.content = [];\n  }\n\n  static getFromPath(path, root) {\n    let el = root[path[0]];\n    if (path.length === 1) return el;\n    return RootSection.getFromPath(path.slice(1), el.content);\n  }\n\n  addQuestion(sectionPath, q) {\n    if (!q) q = new QAQuestion();\n    this.questions;\n    let section = RootSection.getFromPath(sectionPath, [this]);\n\n    if (!(section instanceof QAQuestion)) {\n      section.content.push(q);\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/anujwagle/Desktop/temp/datapali-dashboard/src/components/section.tsx"],"names":["ButtonGroup","QuestionSection","QAQuestion","React","QuestionButton","DPFormItem","SectionButton","DuplicateSettings","SectionC","Component","constructor","props","state","handleQuestionChange","q","path","handleDuplicatingSettingsSave","id","dupe","handleSectionDuplicatingSettingsChange","handleDuplicatingSettingsCancel","render","comp","readablePath","getReadablePath","parentPath","section","content","map","item","index","childPath","concat","handleDeleteChildSectionOrQuestion","handleSectionClick","definedQuestions","d","bind","duplicatingSettings","nu","slice","join","RootSection","questions","sections","getFromPath","root","el","length","addQuestion","sectionPath","push"],"mappings":"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","sourcesContent":["import { ButtonGroup } from \"@blueprintjs/core\";\nimport { QuestionSection } from \"./SurveyForm\";\nimport { QAQuestion } from \"../form/question\";\nimport React from \"react\";\nimport { QuestionButton } from \"./questionButton\";\nimport { DPFormItem } from \"./DPFormItem\";\nimport { SectionButton } from \"./sectionButton\";\nimport { DuplicateSettings, DupeSettings } from \"./duplicateSettings\";\n\ninterface SectionCProps {\n    section: QuestionSection,\n    definedQuestions : QAQuestion[],\n    handleQuestionChange: (question: QAQuestion, _path: number[]) => void,\n    parentPath: number[],\n    handleDeleteChildSectionOrQuestion: (deleteid: string, _path: number[]) => void,\n    handleSectionDuplicatingSettingsChange :(id:string, dupe: DupeSettings)=>void,\n    handleSectionClick: (sectionid: string, _path: number[]) => void,\n}\ninterface SectionCState {\n}\nexport class SectionC extends React.Component<SectionCProps, SectionCState>{\n    constructor(props: SectionCProps) {\n        super(props);\n        this.state = {\n        }\n    }\n\n    handleQuestionChange(q: QAQuestion, path: number[]) {\n        if (this.props.handleQuestionChange) this.props.handleQuestionChange(q, path);\n    }\n    handleDuplicatingSettingsSave(id: string, dupe: DupeSettings){\n        if(this.props.handleSectionDuplicatingSettingsChange) this.props.handleSectionDuplicatingSettingsChange(id, dupe)\n    }\n    handleDuplicatingSettingsCancel(){\n\n    }\n\n    render() {\n        let comp = null;\n        let readablePath = getReadablePath(this.props.parentPath);\n        if (readablePath) readablePath += \".\";\n        comp = this.props.section.content.map((item, index) => {\n            let childPath = this.props.parentPath.concat(index);\n            if (item instanceof QAQuestion) {\n                return <QuestionButton path={childPath} questionId={item.id} handleDeletion={this.props.handleDeleteChildSectionOrQuestion} readablePath={readablePath + (index + 1)} key={item.id} isExpanded={false}>\n                    <DPFormItem onChange={(q) => this.handleQuestionChange(q, childPath)} question={item} />\n                </QuestionButton>\n            }\n            else if (item instanceof QuestionSection) {\n                return <SectionButton path={childPath} handleDeletion={this.props.handleDeleteChildSectionOrQuestion} sectionId={item.id} readablePath={readablePath + (index + 1)} key={item.id} onClick={this.props.handleSectionClick}>\n                    <DuplicateSettings definedQuestions = {this.props.definedQuestions} handleSave = {(d)=>this.handleDuplicatingSettingsSave(item.id,d )} handleCancel={this.handleDuplicatingSettingsCancel.bind(this)} {...item.duplicatingSettings} />\n                </SectionButton>\n            }\n            return null;\n        })\n        return (\n            <ButtonGroup fill vertical>\n                {comp}\n\n            </ButtonGroup>\n\n        )\n    }\n}\n\n\n\nexport function getReadablePath(nu: number[]) {\n    return nu.slice(1).map(item => item + 1).join(\".\");\n\n}\n\n\nclass RootSection {\n    questions: {[key:string]: QAQuestion} = {};\n    sections: {[key: string]: QuestionSection} = {};\n    content: (QuestionSection|QAQuestion)[]=[];\n    constructor(){\n    }\n    \n    static getFromPath(path:number[], root:(RootSection| QuestionSection| QAQuestion)[] ) : RootSection|QuestionSection|QAQuestion{\n        let el = root[path[0]];\n        if(path.length ===1) return el;\n        return RootSection.getFromPath(path.slice(1), el.content)\n    }\n    addQuestion( sectionPath: number[],q: QAQuestion,){\n        if(!q) q = new QAQuestion();\n        this.questions\n        let section = RootSection.getFromPath(sectionPath, [this])\n        if(!(section instanceof QAQuestion)){\n            section.content.push(q);\n        }\n    }\n}"]},"metadata":{},"sourceType":"module"}