{"ast":null,"code":"import { QACondition } from \"../form/condition\";\nimport _ from \"lodash\";\nimport { optionToJSON, optionGroupToJSON, optionFromJSON } from \"../utils/util\";\nexport class AnswerOptions {\n  constructor() {\n    this.optionsMap = {};\n    this.optionGroupMap = {};\n    this.options = [];\n    this.opt_count = 0;\n    this.group_count = 0;\n  }\n\n  static toJSON(a) {\n    return {\n      optionsMap: a && a.optionsMap ? _.mapValues(a.optionsMap, v => optionToJSON(v)) : {},\n      optionGroupMap: a && a.optionGroupMap ? _.mapValues(a.optionGroupMap, v => optionGroupToJSON(v)) : {}\n    };\n  }\n\n  static fromJSON(d) {\n    let r = new AnswerOptions();\n    r.optionsMap = _.mapValues(d.optionsMap, v => optionFromJSON(v));\n    r.optionGroupMap = _.mapValues(d.optionGroupMap, v => {\n      let rr = {\n        id: v.id,\n        name: v.name,\n        appearingCondition: QACondition.fromJSON(v.appearingCondition),\n        members: v.members.map(item => r.optionsMap[item.id])\n      };\n      console.log(rr);\n      return rr;\n    });\n    return r;\n  }\n\n  get SortedOptions() {\n    let grouplessOptions = Object.values(this.optionsMap).filter(item => !item.groupName);\n    let groups = Object.values(this.optionGroupMap);\n    return {\n      groups: groups,\n      rootOptions: grouplessOptions\n    };\n  }\n\n  addOption(option, groupname) {\n    if (!option) {\n      option = {\n        id: 'opt-' + this.opt_count,\n        value: undefined,\n        groupName: groupname\n      };\n    }\n\n    this.optionsMap[option.id] = option;\n\n    if (groupname) {\n      let group = this.optionGroupMap[groupname];\n\n      if (!group) {\n        group = {\n          id: \"opt-grp-\" + this.group_count,\n          name: groupname,\n          appearingCondition: undefined,\n          members: [option]\n        };\n        this.optionGroupMap[groupname] = group;\n        this.group_count++;\n      }\n\n      this.options.push(group);\n    } else {\n      this.options.push(option);\n    }\n\n    this.opt_count++;\n    return this;\n  }\n\n  addGroup(groupname) {\n    let group = {\n      id: \"opt-grp\" + this.group_count,\n      name: groupname || \"group-\".concat(this.group_count),\n      appearingCondition: undefined,\n      members: []\n    };\n    this.optionGroupMap[group.name] = group;\n    this.options.push(group);\n    this.group_count++;\n    return group;\n  }\n\n  setValueForOption(id, newValue) {\n    let option = this.optionsMap[id];\n\n    if (option) {\n      option.value = newValue;\n    }\n\n    return this;\n  }\n\n  deleteOption(id) {\n    let opt = this.optionsMap[id];\n\n    if (opt) {\n      delete this.optionsMap[id];\n      let groupname = opt.groupName;\n\n      if (groupname) {\n        let group = this.optionGroupMap[groupname];\n\n        if (group) {\n          let ind = group.members.findIndex(item => item.id === id);\n\n          if (ind > -1) {\n            group.members.splice(ind, 1);\n          }\n        }\n      }\n    }\n\n    return this;\n  }\n\n  assignOptionToGroup(optionIds, groupName) {\n    let existingGroup = this.optionGroupMap[groupName];\n\n    if (!existingGroup) {\n      existingGroup = this.addGroup(groupName);\n      this.optionGroupMap[existingGroup.name] = existingGroup;\n    }\n\n    for (let i = 0; i < optionIds.length; i++) {\n      let optionId = optionIds[i];\n      let option = this.optionsMap[optionId];\n      let option_group = option.groupName && this.optionGroupMap[option.groupName];\n      if (existingGroup.members.find(item => item.id === optionId)) continue; //unassign from the group the option is in \n\n      if (option_group) {\n        let find = option_group.members.findIndex(item => item.id === option.id);\n\n        if (find > -1) {\n          option_group.members.splice(find, 1);\n        }\n      }\n\n      option.groupName = existingGroup.name;\n      existingGroup.members.push(option);\n    }\n\n    return this;\n  }\n\n  setConditionForOption(optionId, condition) {\n    let option = this.optionsMap[optionId];\n    if (option) option.appearingCondition = condition;\n    return this;\n  }\n\n  setConditionForGroup(groupname, condition) {\n    let group = this.optionGroupMap[groupname];\n    if (group) group.appearingCondition = condition;\n    return this;\n  }\n\n  unassignGroup(ids) {\n    ids.forEach(id => {\n      let option = this.optionsMap[id];\n      let opt_groupname = option.groupName;\n\n      if (option && opt_groupname) {\n        let optgroup = this.optionGroupMap[opt_groupname];\n\n        if (optgroup) {\n          let ind = optgroup.members.findIndex(item => item.id === id);\n          optgroup.members.splice(ind, 1);\n        }\n      }\n\n      if (option) {\n        option.groupName = undefined;\n      }\n    });\n  }\n\n  changeGroupName(oldname, newname) {\n    let group = this.optionGroupMap[oldname];\n    let members_ids = group.members.map(item => item.id);\n\n    if (members_ids) {\n      members_ids.forEach(id => {\n        let option = this.optionsMap[id];\n        if (option) option.groupName = newname;\n      });\n    }\n\n    if (group) {\n      group.name = newname;\n\n      let newGroup = _.clone(group);\n\n      delete this.optionGroupMap[oldname];\n      this.optionGroupMap[newname] = newGroup;\n    }\n  }\n\n  deleteGroup(name) {\n    let group = this.optionGroupMap[name];\n    if (!group) return this;\n    let members_ids = group.members.map(item => item.id);\n\n    if (members_ids) {\n      members_ids.forEach(id => {\n        let option = this.optionsMap[id];\n        if (option) option.groupName = undefined;\n      });\n    }\n\n    delete this.optionGroupMap[name];\n  }\n\n  setOptionTypeFor(optionId, newType) {\n    let opt = this.optionsMap[optionId];\n\n    if (opt) {\n      opt.type = newType;\n      opt.value = undefined;\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/anujwagle/Desktop/temp/datapali-dashboard/src/components/AnswerOptions.tsx"],"names":["QACondition","_","optionToJSON","optionGroupToJSON","optionFromJSON","AnswerOptions","optionsMap","optionGroupMap","options","opt_count","group_count","toJSON","a","mapValues","v","fromJSON","d","r","rr","id","name","appearingCondition","members","map","item","console","log","SortedOptions","grouplessOptions","Object","values","filter","groupName","groups","rootOptions","addOption","option","groupname","value","undefined","group","push","addGroup","setValueForOption","newValue","deleteOption","opt","ind","findIndex","splice","assignOptionToGroup","optionIds","existingGroup","i","length","optionId","option_group","find","setConditionForOption","condition","setConditionForGroup","unassignGroup","ids","forEach","opt_groupname","optgroup","changeGroupName","oldname","newname","members_ids","newGroup","clone","deleteGroup","setOptionTypeFor","newType","type"],"mappings":"AAAA,SAASA,WAAT,QAA4B,mBAA5B;AAEA,OAAOC,CAAP,MAAc,QAAd;AACA,SAASC,YAAT,EAAuBC,iBAAvB,EAA0CC,cAA1C,QAAgE,eAAhE;AAiBA,OAAO,MAAMC,aAAN,CAAoB;AAAA;AAAA,SACvBC,UADuB,GAGnB,EAHmB;AAAA,SAIvBC,cAJuB,GAMnB,EANmB;AAAA,SAOvBC,OAPuB,GAOe,EAPf;AAAA,SAQfC,SARe,GAQK,CARL;AAAA,SASfC,WATe,GASO,CATP;AAAA;;AAWvB,SAAOC,MAAP,CAAcC,CAAd,EAAgC;AAC5B,WAAO;AACHN,MAAAA,UAAU,EAAEM,CAAC,IAAIA,CAAC,CAACN,UAAP,GAAoBL,CAAC,CAACY,SAAF,CAAYD,CAAC,CAACN,UAAd,EAA2BQ,CAAC,IAAIZ,YAAY,CAACY,CAAD,CAA5C,CAApB,GAAwE,EADjF;AAEHP,MAAAA,cAAc,EAAEK,CAAC,IAAIA,CAAC,CAACL,cAAP,GAAwBN,CAAC,CAACY,SAAF,CAAYD,CAAC,CAACL,cAAd,EAA+BO,CAAD,IAAOX,iBAAiB,CAACW,CAAD,CAAtD,CAAxB,GAAqF;AAFlG,KAAP;AAIH;;AAED,SAAOC,QAAP,CAAgBC,CAAhB,EAAuC;AACnC,QAAIC,CAAC,GAAG,IAAIZ,aAAJ,EAAR;AACAY,IAAAA,CAAC,CAACX,UAAF,GAAeL,CAAC,CAACY,SAAF,CAAYG,CAAC,CAACV,UAAd,EAA2BQ,CAAD,IAAOV,cAAc,CAACU,CAAD,CAA/C,CAAf;AACAG,IAAAA,CAAC,CAACV,cAAF,GAAmBN,CAAC,CAACY,SAAF,CAAYG,CAAC,CAACT,cAAd,EAA8BO,CAAC,IAAI;AAClD,UAAII,EAAgB,GAAG;AACnBC,QAAAA,EAAE,EAAEL,CAAC,CAACK,EADa;AAEnBC,QAAAA,IAAI,EAAEN,CAAC,CAACM,IAFW;AAGnBC,QAAAA,kBAAkB,EAAErB,WAAW,CAACe,QAAZ,CAAqBD,CAAC,CAACO,kBAAvB,CAHD;AAInBC,QAAAA,OAAO,EAAER,CAAC,CAACQ,OAAF,CAAUC,GAAV,CAAeC,IAAD,IAAeP,CAAC,CAACX,UAAF,CAAakB,IAAI,CAACL,EAAlB,CAA7B;AAJU,OAAvB;AAMAM,MAAAA,OAAO,CAACC,GAAR,CAAYR,EAAZ;AACA,aAAOA,EAAP;AACH,KATkB,CAAnB;AAUA,WAAOD,CAAP;AACH;;AACD,MAAIU,aAAJ,GAAoB;AAChB,QAAIC,gBAAgB,GAAGC,MAAM,CAACC,MAAP,CAAc,KAAKxB,UAAnB,EAA+ByB,MAA/B,CAAsCP,IAAI,IAAI,CAACA,IAAI,CAACQ,SAApD,CAAvB;AACA,QAAIC,MAAM,GAAGJ,MAAM,CAACC,MAAP,CAAc,KAAKvB,cAAnB,CAAb;AACA,WAAO;AACH0B,MAAAA,MAAM,EAAEA,MADL;AAEHC,MAAAA,WAAW,EAAEN;AAFV,KAAP;AAIH;;AACDO,EAAAA,SAAS,CAACC,MAAD,EAAmBC,SAAnB,EAAuC;AAC5C,QAAI,CAACD,MAAL,EAAa;AACTA,MAAAA,MAAM,GAAG;AAAEjB,QAAAA,EAAE,EAAE,SAAS,KAAKV,SAApB;AAA+B6B,QAAAA,KAAK,EAAEC,SAAtC;AAAiDP,QAAAA,SAAS,EAAEK;AAA5D,OAAT;AACH;;AACD,SAAK/B,UAAL,CAAgB8B,MAAM,CAACjB,EAAvB,IAA6BiB,MAA7B;;AACA,QAAIC,SAAJ,EAAe;AACX,UAAIG,KAAmB,GAAG,KAAKjC,cAAL,CAAoB8B,SAApB,CAA1B;;AACA,UAAI,CAACG,KAAL,EAAY;AACRA,QAAAA,KAAK,GAAG;AAAErB,UAAAA,EAAE,EAAE,aAAa,KAAKT,WAAxB;AAAqCU,UAAAA,IAAI,EAAEiB,SAA3C;AAAsDhB,UAAAA,kBAAkB,EAAEkB,SAA1E;AAAqFjB,UAAAA,OAAO,EAAE,CAACc,MAAD;AAA9F,SAAR;AACA,aAAK7B,cAAL,CAAoB8B,SAApB,IAAiCG,KAAjC;AACA,aAAK9B,WAAL;AACH;;AACD,WAAKF,OAAL,CAAaiC,IAAb,CAAkBD,KAAlB;AACH,KARD,MASK;AACD,WAAKhC,OAAL,CAAaiC,IAAb,CAAkBL,MAAlB;AACH;;AACD,SAAK3B,SAAL;AACA,WAAO,IAAP;AACH;;AACDiC,EAAAA,QAAQ,CAACL,SAAD,EAAqB;AACzB,QAAIG,KAAmB,GAAG;AAAErB,MAAAA,EAAE,EAAE,YAAY,KAAKT,WAAvB;AAAoCU,MAAAA,IAAI,EAAEiB,SAAS,oBAAa,KAAK3B,WAAlB,CAAnD;AAAoFW,MAAAA,kBAAkB,EAAEkB,SAAxG;AAAmHjB,MAAAA,OAAO,EAAE;AAA5H,KAA1B;AACA,SAAKf,cAAL,CAAoBiC,KAAK,CAACpB,IAA1B,IAAkCoB,KAAlC;AACA,SAAKhC,OAAL,CAAaiC,IAAb,CAAkBD,KAAlB;AACA,SAAK9B,WAAL;AACA,WAAO8B,KAAP;AACH;;AAEDG,EAAAA,iBAAiB,CAACxB,EAAD,EAAayB,QAAb,EAA+B;AAC5C,QAAIR,MAAM,GAAG,KAAK9B,UAAL,CAAgBa,EAAhB,CAAb;;AACA,QAAIiB,MAAJ,EAAY;AACRA,MAAAA,MAAM,CAACE,KAAP,GAAeM,QAAf;AACH;;AACD,WAAO,IAAP;AACH;;AAEDC,EAAAA,YAAY,CAAC1B,EAAD,EAAa;AACrB,QAAI2B,GAAG,GAAG,KAAKxC,UAAL,CAAgBa,EAAhB,CAAV;;AACA,QAAI2B,GAAJ,EAAS;AACL,aAAO,KAAKxC,UAAL,CAAgBa,EAAhB,CAAP;AACA,UAAIkB,SAAS,GAAGS,GAAG,CAACd,SAApB;;AACA,UAAIK,SAAJ,EAAe;AACX,YAAIG,KAAK,GAAG,KAAKjC,cAAL,CAAoB8B,SAApB,CAAZ;;AACA,YAAIG,KAAJ,EAAW;AACP,cAAIO,GAAG,GAAGP,KAAK,CAAClB,OAAN,CAAc0B,SAAd,CAAwBxB,IAAI,IAAIA,IAAI,CAACL,EAAL,KAAYA,EAA5C,CAAV;;AACA,cAAI4B,GAAG,GAAG,CAAC,CAAX,EAAc;AACVP,YAAAA,KAAK,CAAClB,OAAN,CAAc2B,MAAd,CAAqBF,GAArB,EAA0B,CAA1B;AACH;AACJ;AACJ;AACJ;;AACD,WAAO,IAAP;AACH;;AACDG,EAAAA,mBAAmB,CAACC,SAAD,EAAsBnB,SAAtB,EAAyC;AACxD,QAAIoB,aAAa,GAAG,KAAK7C,cAAL,CAAoByB,SAApB,CAApB;;AACA,QAAI,CAACoB,aAAL,EAAoB;AAChBA,MAAAA,aAAa,GAAG,KAAKV,QAAL,CAAcV,SAAd,CAAhB;AACA,WAAKzB,cAAL,CAAoB6C,aAAa,CAAChC,IAAlC,IAA0CgC,aAA1C;AACH;;AACD,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,SAAS,CAACG,MAA9B,EAAsCD,CAAC,EAAvC,EAA2C;AACvC,UAAIE,QAAQ,GAAGJ,SAAS,CAACE,CAAD,CAAxB;AACA,UAAIjB,MAAM,GAAG,KAAK9B,UAAL,CAAgBiD,QAAhB,CAAb;AACA,UAAIC,YAAY,GAAGpB,MAAM,CAACJ,SAAP,IAAoB,KAAKzB,cAAL,CAAoB6B,MAAM,CAACJ,SAA3B,CAAvC;AACA,UAAIoB,aAAa,CAAC9B,OAAd,CAAsBmC,IAAtB,CAA2BjC,IAAI,IAAIA,IAAI,CAACL,EAAL,KAAYoC,QAA/C,CAAJ,EACI,SALmC,CAMvC;;AACA,UAAIC,YAAJ,EAAkB;AACd,YAAIC,IAAI,GAAGD,YAAY,CAAClC,OAAb,CAAqB0B,SAArB,CAA+BxB,IAAI,IAAIA,IAAI,CAACL,EAAL,KAAYiB,MAAM,CAACjB,EAA1D,CAAX;;AACA,YAAIsC,IAAI,GAAG,CAAC,CAAZ,EAAe;AACXD,UAAAA,YAAY,CAAClC,OAAb,CAAqB2B,MAArB,CAA4BQ,IAA5B,EAAkC,CAAlC;AACH;AACJ;;AACDrB,MAAAA,MAAM,CAACJ,SAAP,GAAmBoB,aAAa,CAAChC,IAAjC;AACAgC,MAAAA,aAAa,CAAC9B,OAAd,CAAsBmB,IAAtB,CAA2BL,MAA3B;AACH;;AACD,WAAO,IAAP;AACH;;AACDsB,EAAAA,qBAAqB,CAACH,QAAD,EAAmBI,SAAnB,EAA2C;AAC5D,QAAIvB,MAAM,GAAG,KAAK9B,UAAL,CAAgBiD,QAAhB,CAAb;AACA,QAAInB,MAAJ,EACIA,MAAM,CAACf,kBAAP,GAA4BsC,SAA5B;AACJ,WAAO,IAAP;AACH;;AACDC,EAAAA,oBAAoB,CAACvB,SAAD,EAAoBsB,SAApB,EAA4C;AAC5D,QAAInB,KAAK,GAAG,KAAKjC,cAAL,CAAoB8B,SAApB,CAAZ;AACA,QAAIG,KAAJ,EACIA,KAAK,CAACnB,kBAAN,GAA2BsC,SAA3B;AACJ,WAAO,IAAP;AACH;;AACDE,EAAAA,aAAa,CAACC,GAAD,EAAgB;AACzBA,IAAAA,GAAG,CAACC,OAAJ,CAAY5C,EAAE,IAAI;AACd,UAAIiB,MAAM,GAAG,KAAK9B,UAAL,CAAgBa,EAAhB,CAAb;AACA,UAAI6C,aAAa,GAAG5B,MAAM,CAACJ,SAA3B;;AACA,UAAII,MAAM,IAAI4B,aAAd,EAA6B;AACzB,YAAIC,QAAQ,GAAG,KAAK1D,cAAL,CAAoByD,aAApB,CAAf;;AACA,YAAIC,QAAJ,EAAc;AACV,cAAIlB,GAAG,GAAGkB,QAAQ,CAAC3C,OAAT,CAAiB0B,SAAjB,CAA2BxB,IAAI,IAAIA,IAAI,CAACL,EAAL,KAAYA,EAA/C,CAAV;AACA8C,UAAAA,QAAQ,CAAC3C,OAAT,CAAiB2B,MAAjB,CAAwBF,GAAxB,EAA6B,CAA7B;AACH;AACJ;;AACD,UAAIX,MAAJ,EAAY;AACRA,QAAAA,MAAM,CAACJ,SAAP,GAAmBO,SAAnB;AACH;AACJ,KAbD;AAcH;;AACD2B,EAAAA,eAAe,CAACC,OAAD,EAAkBC,OAAlB,EAAmC;AAC9C,QAAI5B,KAAK,GAAG,KAAKjC,cAAL,CAAoB4D,OAApB,CAAZ;AACA,QAAIE,WAAW,GAAG7B,KAAK,CAAClB,OAAN,CAAcC,GAAd,CAAkBC,IAAI,IAAIA,IAAI,CAACL,EAA/B,CAAlB;;AACA,QAAIkD,WAAJ,EAAiB;AACbA,MAAAA,WAAW,CAACN,OAAZ,CAAoB5C,EAAE,IAAI;AACtB,YAAIiB,MAAM,GAAG,KAAK9B,UAAL,CAAgBa,EAAhB,CAAb;AACA,YAAIiB,MAAJ,EACIA,MAAM,CAACJ,SAAP,GAAmBoC,OAAnB;AACP,OAJD;AAKH;;AACD,QAAI5B,KAAJ,EAAW;AACPA,MAAAA,KAAK,CAACpB,IAAN,GAAagD,OAAb;;AACA,UAAIE,QAAQ,GAAGrE,CAAC,CAACsE,KAAF,CAAQ/B,KAAR,CAAf;;AACA,aAAO,KAAKjC,cAAL,CAAoB4D,OAApB,CAAP;AACA,WAAK5D,cAAL,CAAoB6D,OAApB,IAA+BE,QAA/B;AACH;AACJ;;AACDE,EAAAA,WAAW,CAACpD,IAAD,EAAe;AACtB,QAAIoB,KAAK,GAAG,KAAKjC,cAAL,CAAoBa,IAApB,CAAZ;AACA,QAAI,CAACoB,KAAL,EACI,OAAO,IAAP;AACJ,QAAI6B,WAAW,GAAG7B,KAAK,CAAClB,OAAN,CAAcC,GAAd,CAAkBC,IAAI,IAAIA,IAAI,CAACL,EAA/B,CAAlB;;AACA,QAAIkD,WAAJ,EAAiB;AACbA,MAAAA,WAAW,CAACN,OAAZ,CAAoB5C,EAAE,IAAI;AACtB,YAAIiB,MAAM,GAAG,KAAK9B,UAAL,CAAgBa,EAAhB,CAAb;AACA,YAAIiB,MAAJ,EACIA,MAAM,CAACJ,SAAP,GAAmBO,SAAnB;AACP,OAJD;AAKH;;AACD,WAAO,KAAKhC,cAAL,CAAoBa,IAApB,CAAP;AACH;;AACDqD,EAAAA,gBAAgB,CAAClB,QAAD,EAAmBmB,OAAnB,EAAwC;AACpD,QAAI5B,GAAG,GAAG,KAAKxC,UAAL,CAAgBiD,QAAhB,CAAV;;AACA,QAAIT,GAAJ,EAAS;AACLA,MAAAA,GAAG,CAAC6B,IAAJ,GAAWD,OAAX;AACA5B,MAAAA,GAAG,CAACR,KAAJ,GAAYC,SAAZ;AACH;AACJ;;AAvLsB","sourcesContent":["import { QACondition } from \"../form/condition\";\nimport { IValueType } from \"./AnswerType\";\nimport _ from \"lodash\";\nimport { optionToJSON, optionGroupToJSON, optionFromJSON } from \"../utils/util\";\n\nexport interface IOption {\n    appearingCondition?: QACondition;\n    type?: IValueType;\n    id: string,\n    value?: string\n    groupName?: string\n}\n\nexport interface IOptionGroup {\n    id: string,\n    name: string,\n    appearingCondition?: QACondition,\n    members: IOption[],\n}\n\nexport class AnswerOptions {\n    optionsMap: {\n        [key: string]: IOption;\n    } = {};\n    optionGroupMap: {\n        [key: string]: IOptionGroup;\n    } = {};\n    options: (IOption | IOptionGroup)[] = [];\n    private opt_count: number = 0;\n    private group_count: number = 0;\n\n    static toJSON(a: AnswerOptions) {\n        return {\n            optionsMap: a && a.optionsMap ? _.mapValues(a.optionsMap, (v => optionToJSON(v))) : {},\n            optionGroupMap: a && a.optionGroupMap ? _.mapValues(a.optionGroupMap, (v) => optionGroupToJSON(v)) : {}\n        }\n    }\n\n    static fromJSON(d: any): AnswerOptions {\n        let r = new AnswerOptions();\n        r.optionsMap = _.mapValues(d.optionsMap, (v) => optionFromJSON(v));\n        r.optionGroupMap = _.mapValues(d.optionGroupMap, v => {\n            let rr: IOptionGroup = {\n                id: v.id,\n                name: v.name,\n                appearingCondition: QACondition.fromJSON(v.appearingCondition),\n                members: v.members.map((item: any) => r.optionsMap[item.id]),\n            }\n            console.log(rr);\n            return rr;\n        });\n        return r;\n    }\n    get SortedOptions() {\n        let grouplessOptions = Object.values(this.optionsMap).filter(item => !item.groupName);\n        let groups = Object.values(this.optionGroupMap);\n        return {\n            groups: groups,\n            rootOptions: grouplessOptions\n        };\n    }\n    addOption(option?: IOption, groupname?: string) {\n        if (!option) {\n            option = { id: 'opt-' + this.opt_count, value: undefined, groupName: groupname };\n        }\n        this.optionsMap[option.id] = option;\n        if (groupname) {\n            let group: IOptionGroup = this.optionGroupMap[groupname];\n            if (!group) {\n                group = { id: \"opt-grp-\" + this.group_count, name: groupname, appearingCondition: undefined, members: [option] };\n                this.optionGroupMap[groupname] = group;\n                this.group_count++;\n            }\n            this.options.push(group);\n        }\n        else {\n            this.options.push(option);\n        }\n        this.opt_count++;\n        return this;\n    }\n    addGroup(groupname?: string) {\n        let group: IOptionGroup = { id: \"opt-grp\" + this.group_count, name: groupname || `group-${this.group_count}`, appearingCondition: undefined, members: [] };\n        this.optionGroupMap[group.name] = group;\n        this.options.push(group);\n        this.group_count++;\n        return group;\n    }\n\n    setValueForOption(id: string, newValue: string) {\n        let option = this.optionsMap[id];\n        if (option) {\n            option.value = newValue;\n        }\n        return this;\n    }\n\n    deleteOption(id: string) {\n        let opt = this.optionsMap[id];\n        if (opt) {\n            delete this.optionsMap[id];\n            let groupname = opt.groupName;\n            if (groupname) {\n                let group = this.optionGroupMap[groupname];\n                if (group) {\n                    let ind = group.members.findIndex(item => item.id === id);\n                    if (ind > -1) {\n                        group.members.splice(ind, 1);\n                    }\n                }\n            }\n        }\n        return this;\n    }\n    assignOptionToGroup(optionIds: string[], groupName: string) {\n        let existingGroup = this.optionGroupMap[groupName];\n        if (!existingGroup) {\n            existingGroup = this.addGroup(groupName);\n            this.optionGroupMap[existingGroup.name] = existingGroup;\n        }\n        for (let i = 0; i < optionIds.length; i++) {\n            let optionId = optionIds[i];\n            let option = this.optionsMap[optionId];\n            let option_group = option.groupName && this.optionGroupMap[option.groupName];\n            if (existingGroup.members.find(item => item.id === optionId))\n                continue;\n            //unassign from the group the option is in \n            if (option_group) {\n                let find = option_group.members.findIndex(item => item.id === option.id);\n                if (find > -1) {\n                    option_group.members.splice(find, 1);\n                }\n            }\n            option.groupName = existingGroup.name;\n            existingGroup.members.push(option);\n        }\n        return this;\n    }\n    setConditionForOption(optionId: string, condition: QACondition) {\n        let option = this.optionsMap[optionId];\n        if (option)\n            option.appearingCondition = condition;\n        return this;\n    }\n    setConditionForGroup(groupname: string, condition: QACondition) {\n        let group = this.optionGroupMap[groupname];\n        if (group)\n            group.appearingCondition = condition;\n        return this;\n    }\n    unassignGroup(ids: string[]) {\n        ids.forEach(id => {\n            let option = this.optionsMap[id];\n            let opt_groupname = option.groupName;\n            if (option && opt_groupname) {\n                let optgroup = this.optionGroupMap[opt_groupname];\n                if (optgroup) {\n                    let ind = optgroup.members.findIndex(item => item.id === id);\n                    optgroup.members.splice(ind, 1);\n                }\n            }\n            if (option) {\n                option.groupName = undefined;\n            }\n        });\n    }\n    changeGroupName(oldname: string, newname: string) {\n        let group = this.optionGroupMap[oldname];\n        let members_ids = group.members.map(item => item.id);\n        if (members_ids) {\n            members_ids.forEach(id => {\n                let option = this.optionsMap[id];\n                if (option)\n                    option.groupName = newname;\n            });\n        }\n        if (group) {\n            group.name = newname;\n            let newGroup = _.clone(group);\n            delete this.optionGroupMap[oldname];\n            this.optionGroupMap[newname] = newGroup;\n        }\n    }\n    deleteGroup(name: string) {\n        let group = this.optionGroupMap[name];\n        if (!group)\n            return this;\n        let members_ids = group.members.map(item => item.id);\n        if (members_ids) {\n            members_ids.forEach(id => {\n                let option = this.optionsMap[id];\n                if (option)\n                    option.groupName = undefined;\n            });\n        }\n        delete this.optionGroupMap[name];\n    }\n    setOptionTypeFor(optionId: string, newType: IValueType) {\n        let opt = this.optionsMap[optionId];\n        if (opt) {\n            opt.type = newType;\n            opt.value = undefined;\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}