{"ast":null,"code":"var _jsxFileName = \"/Users/anujwagle/Desktop/temp/datapali-dashboard/src/components/section.tsx\";\nimport { ButtonGroup } from \"@blueprintjs/core\";\nimport { QuestionSection } from \"./SurveyForm\";\nimport { QAQuestion } from \"../form/question\";\nimport React from \"react\";\nimport { QuestionButton } from \"./questionButton\";\nimport { DPFormItem } from \"./DPFormItem\";\nimport { SectionButton } from \"./sectionButton\";\nimport { DuplicateSettings } from \"./duplicateSettings\";\nexport class SectionC extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n\n  handleQuestionChange(q, path) {\n    if (this.props.handleQuestionChange) this.props.handleQuestionChange(q, path);\n  }\n\n  handleDuplicatingSettingsSave(id, dupe) {\n    if (this.props.handleSectionDuplicatingSettingsChange) this.props.handleSectionDuplicatingSettingsChange(id, dupe);\n  }\n\n  handleDuplicatingSettingsCancel() {}\n\n  render() {\n    let comp = null;\n    let readablePath = getReadablePath(this.props.parentPath);\n    if (readablePath) readablePath += \".\";\n    comp = this.props.section.content.map((item, index) => {\n      let childPath = this.props.parentPath.concat(index);\n\n      if (item instanceof QAQuestion) {\n        return React.createElement(QuestionButton, {\n          path: childPath,\n          questionId: item.id,\n          handleDeletion: this.props.handleDeleteChildSectionOrQuestion,\n          readablePath: readablePath + (index + 1),\n          key: item.id,\n          isExpanded: false,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 45\n          },\n          __self: this\n        }, React.createElement(DPFormItem, {\n          onChange: q => this.handleQuestionChange(q, childPath),\n          question: item,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 46\n          },\n          __self: this\n        }));\n      } else if (item instanceof QuestionSection) {\n        return React.createElement(SectionButton, {\n          path: childPath,\n          handleDeletion: this.props.handleDeleteChildSectionOrQuestion,\n          sectionId: item.id,\n          readablePath: readablePath + (index + 1),\n          key: item.id,\n          onClick: this.props.handleSectionClick,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 50\n          },\n          __self: this\n        }, React.createElement(DuplicateSettings, Object.assign({\n          definedQuestions: this.props.definedQuestions,\n          handleSave: d => this.handleDuplicatingSettingsSave(item.id, d),\n          handleCancel: this.handleDuplicatingSettingsCancel.bind(this)\n        }, item.duplicatingSettings, {\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 51\n          },\n          __self: this\n        })));\n      }\n\n      return null;\n    });\n    return React.createElement(ButtonGroup, {\n      fill: true,\n      vertical: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 57\n      },\n      __self: this\n    }, comp);\n  }\n\n}\nexport function getReadablePath(nu) {\n  return nu.slice(1).map(item => item + 1).join(\".\");\n}\nexport class RootSection {\n  constructor() {\n    this.questions = {};\n    this.sections = {};\n    this.content = [];\n    this.name = void 0;\n  }\n\n  static getFromPath(path, root) {\n    let el = root[path[0]];\n    if (path.length === 1) return el;\n    return RootSection.getFromPath(path.slice(1), el.content);\n  }\n\n  addQuestion(parentPath, q) {\n    if (!q) q = [new QAQuestion()];\n    let section = RootSection.getFromPath(parentPath, [this]);\n\n    for (let i = 0; i < q.length; i++) {\n      let current = q[i];\n      if (this.questions[current.id]) throw new Error(\"Question id conflict\");\n      this.questions[current.id] = current;\n\n      if (!(section instanceof QAQuestion)) {\n        section.content.push(current);\n      }\n    }\n  }\n\n  addSection(parentPath, q) {\n    if (!q) q = [new QuestionSection()];\n    let section = RootSection.getFromPath(parentPath, [this]);\n\n    for (let i = 0; i < q.length; i++) {\n      let current = q[i];\n      if (this.questions[current.id]) throw new Error(\"Section id conflict\");\n      this.sections[current.id] = current;\n\n      if (!(section instanceof QAQuestion)) {\n        section.content.push(current);\n      }\n    }\n  }\n\n  removeQuestion(questionId, path) {\n    let parentSection = RootSection.getFromPath(path, [this]);\n\n    if (!(parentSection instanceof QAQuestion)) {\n      let foundIndex = parentSection.content.findIndex(item => item.id === questionId);\n\n      if (foundIndex > -1) {\n        parentSection.content.splice(foundIndex, 1);\n        delete this.questions[questionId];\n      }\n    }\n  }\n\n  removeSection(sectionId, path) {\n    let parentSection = RootSection.getFromPath(path, [this]);\n\n    if (!(parentSection instanceof QAQuestion)) {\n      let foundIndex = parentSection.content.findIndex(item => item.id === sectionId);\n\n      if (foundIndex > -1) {\n        parentSection.content.splice(foundIndex, 1);\n        delete this.sections[sectionId];\n      }\n    }\n  }\n\n  moveItem(prevPath, newPath) {\n    let itemAtPath = RootSection.getFromPath(prevPath);\n    let newParentPath = newPath.slice(0, newPath.length - 1);\n    let oldParentPath = prevPath.slice(0, prevPath.length - 1);\n    let newParent = RootSection.getFromPath(newParent, this);\n  }\n\n}","map":{"version":3,"sources":["/Users/anujwagle/Desktop/temp/datapali-dashboard/src/components/section.tsx"],"names":["ButtonGroup","QuestionSection","QAQuestion","React","QuestionButton","DPFormItem","SectionButton","DuplicateSettings","SectionC","Component","constructor","props","state","handleQuestionChange","q","path","handleDuplicatingSettingsSave","id","dupe","handleSectionDuplicatingSettingsChange","handleDuplicatingSettingsCancel","render","comp","readablePath","getReadablePath","parentPath","section","content","map","item","index","childPath","concat","handleDeleteChildSectionOrQuestion","handleSectionClick","definedQuestions","d","bind","duplicatingSettings","nu","slice","join","RootSection","questions","sections","name","getFromPath","root","el","length","addQuestion","i","current","Error","push","addSection","removeQuestion","questionId","parentSection","foundIndex","findIndex","splice","removeSection","sectionId","moveItem","prevPath","newPath","itemAtPath","newParentPath","oldParentPath","newParent"],"mappings":"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","sourcesContent":["import { ButtonGroup } from \"@blueprintjs/core\";\nimport { QuestionSection } from \"./SurveyForm\";\nimport { QAQuestion } from \"../form/question\";\nimport React from \"react\";\nimport { QuestionButton } from \"./questionButton\";\nimport { DPFormItem } from \"./DPFormItem\";\nimport { SectionButton } from \"./sectionButton\";\nimport { DuplicateSettings, DupeSettings } from \"./duplicateSettings\";\n\ninterface SectionCProps {\n    section: QuestionSection,\n    definedQuestions : QAQuestion[],\n    handleQuestionChange: (question: QAQuestion, _path: number[]) => void,\n    parentPath: number[],\n    handleDeleteChildSectionOrQuestion: (deleteid: string, _path: number[]) => void,\n    handleSectionDuplicatingSettingsChange :(id:string, dupe: DupeSettings)=>void,\n    handleSectionClick: (sectionid: string, _path: number[]) => void,\n}\ninterface SectionCState {\n}\nexport class SectionC extends React.Component<SectionCProps, SectionCState>{\n    constructor(props: SectionCProps) {\n        super(props);\n        this.state = {\n        }\n    }\n\n    handleQuestionChange(q: QAQuestion, path: number[]) {\n        if (this.props.handleQuestionChange) this.props.handleQuestionChange(q, path);\n    }\n    handleDuplicatingSettingsSave(id: string, dupe: DupeSettings){\n        if(this.props.handleSectionDuplicatingSettingsChange) this.props.handleSectionDuplicatingSettingsChange(id, dupe)\n    }\n    handleDuplicatingSettingsCancel(){\n\n    }\n\n    render() {\n        let comp = null;\n        let readablePath = getReadablePath(this.props.parentPath);\n        if (readablePath) readablePath += \".\";\n        comp = this.props.section.content.map((item, index) => {\n            let childPath = this.props.parentPath.concat(index);\n            if (item instanceof QAQuestion) {\n                return <QuestionButton path={childPath} questionId={item.id} handleDeletion={this.props.handleDeleteChildSectionOrQuestion} readablePath={readablePath + (index + 1)} key={item.id} isExpanded={false}>\n                    <DPFormItem onChange={(q) => this.handleQuestionChange(q, childPath)} question={item} />\n                </QuestionButton>\n            }\n            else if (item instanceof QuestionSection) {\n                return <SectionButton path={childPath} handleDeletion={this.props.handleDeleteChildSectionOrQuestion} sectionId={item.id} readablePath={readablePath + (index + 1)} key={item.id} onClick={this.props.handleSectionClick}>\n                    <DuplicateSettings definedQuestions = {this.props.definedQuestions} handleSave = {(d)=>this.handleDuplicatingSettingsSave(item.id,d )} handleCancel={this.handleDuplicatingSettingsCancel.bind(this)} {...item.duplicatingSettings} />\n                </SectionButton>\n            }\n            return null;\n        })\n        return (\n            <ButtonGroup fill vertical>\n                {comp}\n\n            </ButtonGroup>\n\n        )\n    }\n}\n\n\n\nexport function getReadablePath(nu: number[]) {\n    return nu.slice(1).map(item => item + 1).join(\".\");\n\n}\n\n\nexport class RootSection {\n    questions: {[key:string]: QAQuestion} = {};\n    sections: {[key: string]: QuestionSection} = {};\n    content: (QuestionSection|QAQuestion)[]=[];\n    name!: string;\n    constructor(){\n    }\n    \n    static getFromPath(path:number[], root:(RootSection| QuestionSection| QAQuestion)[] ) : RootSection|QuestionSection|QAQuestion{\n        let el = root[path[0]];\n        if(path.length ===1) return el;\n        return RootSection.getFromPath(path.slice(1), el.content)\n    }\n    \n\n    addQuestion( parentPath: number[], q: (QAQuestion)[]){\n        if(!q) q = [new QAQuestion()];\n        let section = RootSection.getFromPath(parentPath, [this])\n        for(let i = 0; i<q.length;i++){\n            let current = q[i];\n            if(this.questions[current.id]) throw new Error(\"Question id conflict\");\n            this.questions[current.id] = current;\n            if(!(section instanceof QAQuestion)){\n                section.content.push(current);\n            }\n\n\n        }\n    }\n\n    addSection( parentPath: number[], q: (QuestionSection)[]){\n        if(!q) q = [new QuestionSection()];\n        let section = RootSection.getFromPath(parentPath, [this])\n        for(let i = 0; i<q.length;i++){\n            let current = q[i];\n            if(this.questions[current.id]) throw new Error(\"Section id conflict\");\n            this.sections[current.id] = current;\n            if(!(section instanceof QAQuestion)){\n                section.content.push(current);\n            }\n        }\n    }\n    \n    removeQuestion(questionId: string, path: number[]){\n        let parentSection = RootSection.getFromPath(path,[this]);\n        if (!(parentSection instanceof QAQuestion)){\n            let foundIndex = parentSection.content.findIndex(item=>item.id===questionId);\n            if(foundIndex>-1){\n                parentSection.content.splice(foundIndex, 1);\n                delete this.questions[questionId];\n            }\n        }\n    }\n\n    removeSection(sectionId: string, path: number[]){\n        let parentSection = RootSection.getFromPath(path,[this]);\n        if (!(parentSection instanceof QAQuestion)){\n            let foundIndex = parentSection.content.findIndex(item=>item.id===sectionId);\n            if(foundIndex>-1){\n                parentSection.content.splice(foundIndex, 1);\n                delete this.sections[sectionId];\n            }\n        }\n    }\n\n    moveItem(prevPath: number[], newPath:number[]){\n        let itemAtPath = RootSection.getFromPath(prevPath,)\n        let newParentPath = newPath.slice(0, newPath.length-1);\n        let oldParentPath = prevPath.slice(0, prevPath.length-1);\n        let newParent = RootSection.getFromPath(newParent, this)\n    }\n}"]},"metadata":{},"sourceType":"module"}