{"ast":null,"code":"var _jsxFileName = \"/Users/anujwagle/Desktop/temp/datapali-dashboard/src/components/section.tsx\";\nimport { ButtonGroup } from \"@blueprintjs/core\";\nimport { QuestionSection } from \"./SurveyForm\";\nimport { QAQuestion } from \"../form/question\";\nimport React from \"react\";\nimport { QuestionButton } from \"./questionButton\";\nimport { DPFormItem } from \"./DPFormItem\";\nimport { SectionButton } from \"./sectionButton\";\nimport { DuplicateSettings } from \"./duplicateSettings\";\nimport { getRandomId } from \"../utils/getRandomId\";\nimport _ from \"lodash\";\nimport { dupeSettingsFromJSON } from \"../utils/util\";\nexport class SectionC extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n\n  handleQuestionChange(q, path) {\n    if (this.props.handleQuestionChange) this.props.handleQuestionChange(q, path);\n  }\n\n  handleDuplicatingSettingsSave(id, dupe) {\n    if (this.props.handleSectionDuplicatingSettingsChange) this.props.handleSectionDuplicatingSettingsChange(id, dupe);\n  }\n\n  handleDuplicatingSettingsCancel() {}\n\n  render() {\n    let comp = null;\n    let readablePath = getReadablePath(this.props.parentPath);\n    if (readablePath) readablePath += \".\";\n    comp = this.props.section.content.map((item, index) => {\n      let childPath = this.props.parentPath.concat(index);\n\n      if (item instanceof QAQuestion) {\n        return React.createElement(QuestionButton, {\n          path: childPath,\n          questionId: item.id,\n          handleDeletion: this.props.handleDeleteChildSectionOrQuestion,\n          readablePath: readablePath + (index + 1),\n          key: item.id,\n          isExpanded: false,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 48\n          },\n          __self: this\n        }, React.createElement(DPFormItem, {\n          definedQuestions: this.props.definedQuestions,\n          onChange: q => this.handleQuestionChange(q, childPath),\n          question: item,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 49\n          },\n          __self: this\n        }));\n      } else if (item instanceof QuestionSection) {\n        return React.createElement(SectionButton, {\n          path: childPath,\n          handleDeletion: this.props.handleDeleteChildSectionOrQuestion,\n          sectionId: item.id,\n          readablePath: readablePath + (index + 1),\n          key: item.id,\n          onClick: this.props.handleSectionClick,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 53\n          },\n          __self: this\n        }, React.createElement(DuplicateSettings, Object.assign({\n          definedQuestions: this.props.definedQuestions,\n          handleSave: d => this.handleDuplicatingSettingsSave(item.id, d),\n          handleCancel: this.handleDuplicatingSettingsCancel\n        }, item.duplicatingSettings, {\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 54\n          },\n          __self: this\n        })));\n      }\n\n      return null;\n    });\n    return React.createElement(ButtonGroup, {\n      fill: true,\n      vertical: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 60\n      },\n      __self: this\n    }, comp);\n  }\n\n}\nexport function getReadablePath(nu) {\n  return nu.slice(1).map(item => item + 1).join(\".\");\n}\nexport class RootSection {\n  constructor() {\n    this.questions = {};\n    this.sections = {};\n    this.content = [];\n    this.name = void 0;\n    this.id = void 0;\n    this.id = getRandomId(\"root-\");\n  }\n\n  static getFromPath(path, root) {\n    let el = root[path[0]];\n    if (path.length === 1) return el;\n    return RootSection.getFromPath(path.slice(1), el.content);\n  }\n\n  addQuestion(parentPath, q) {\n    if (!q) q = [new QAQuestion()];\n    let section = RootSection.getFromPath(parentPath, [this]);\n\n    for (let i = 0; i < q.length; i++) {\n      let current = q[i];\n      if (this.questions[current.id]) throw new Error(\"Question id conflict\");\n      this.questions[current.id] = current;\n\n      if (!(section instanceof QAQuestion)) {\n        section.content.push(current);\n      }\n    }\n\n    return this;\n  }\n\n  addSection(parentPath, q) {\n    if (!q) q = [new QuestionSection()];\n    let section = RootSection.getFromPath(parentPath, [this]);\n\n    for (let i = 0; i < q.length; i++) {\n      let current = q[i];\n      if (this.questions[current.id]) throw new Error(\"Section id conflict\");\n      this.sections[current.id] = current;\n\n      if (!(section instanceof QAQuestion)) {\n        section.content.push(current);\n      }\n    }\n\n    return this;\n  }\n\n  removeQuestion(questionId, path) {\n    let parentSection = RootSection.getFromPath(path.slice(0, path.length - 1), [this]);\n\n    if (!(parentSection instanceof QAQuestion)) {\n      let foundIndex = parentSection.content.findIndex(item => item.id === questionId);\n\n      if (foundIndex > -1) {\n        parentSection.content.splice(foundIndex, 1);\n        delete this.questions[questionId];\n      }\n    }\n\n    return this;\n  }\n\n  removeSection(sectionId, path) {\n    let parentSection = RootSection.getFromPath(path.slice(0, path.length - 1), [this]);\n\n    if (!(parentSection instanceof QAQuestion)) {\n      let foundIndex = parentSection.content.findIndex(item => item.id === sectionId);\n\n      if (foundIndex > -1) {\n        parentSection.content.splice(foundIndex, 1);\n        delete this.sections[sectionId];\n      }\n    }\n\n    return this;\n  }\n\n  moveItem(prevPath, newPath) {\n    let itemAtPath = RootSection.getFromPath(prevPath, [this]);\n    let newParentPath = newPath.slice(0, newPath.length - 1);\n    let oldParentPath = prevPath.slice(0, prevPath.length - 1);\n    let newParent = RootSection.getFromPath(newParentPath, [this]);\n    let oldParent = RootSection.getFromPath(oldParentPath, [this]);\n    let foundIndex = oldParent.content.findIndex(item => item.id === itemAtPath.id);\n\n    if (foundIndex > -1 && !(oldParent instanceof QAQuestion)) {\n      let removed = oldParent.content.splice(foundIndex, 1);\n\n      if (!(newParent instanceof QAQuestion)) {\n        if (removed instanceof QuestionSection) {\n          newParent.content.push(this.sections[removed[0].id]);\n        } else if (removed instanceof QAQuestion) {\n          newParent.content.push(this.sections[removed[0].id]);\n        }\n      }\n\n      return this;\n    }\n  }\n\n  static toJSON(a) {\n    let r = {\n      id: a.id,\n      name: a.name,\n      content: a.content.map(item => {\n        if (item instanceof QuestionSection) {\n          return QuestionSection.toJSON(item);\n        } else if (item instanceof QAQuestion) {\n          return QAQuestion.toJSON(item);\n        }\n      }),\n      questions: _.mapValues(a.questions, v => QAQuestion.toJSON(v)),\n      sections: _.mapValues(a.sections, v => QuestionSection.toJSON(v))\n    };\n    return r;\n  }\n\n  static fromJSON(a) {\n    let r = new RootSection();\n    let path = [0];\n\n    const handleSectionAdd = (a, parentPath, index) => {\n      if (a.hasOwnProperty(\"content\")) {\n        let section = new QuestionSection();\n        section.id = a.id;\n        section.duplicatingSettings = dupeSettingsFromJSON(a.duplicatingSettings);\n        r.addSection(parentPath, [section]);\n        a.content.forEach((item, i) => handleSectionAdd(item, parentPath.concat(index), i));\n      } else {\n        let question = QAQuestion.fromJSON(a);\n        r.addQuestion(parentPath, [question]);\n      }\n    };\n\n    a.content.forEach((item, index) => handleSectionAdd(item, path, index));\n    return r;\n  }\n\n}","map":{"version":3,"sources":["/Users/anujwagle/Desktop/temp/datapali-dashboard/src/components/section.tsx"],"names":["ButtonGroup","QuestionSection","QAQuestion","React","QuestionButton","DPFormItem","SectionButton","DuplicateSettings","getRandomId","_","dupeSettingsFromJSON","SectionC","Component","constructor","props","state","handleQuestionChange","q","path","handleDuplicatingSettingsSave","id","dupe","handleSectionDuplicatingSettingsChange","handleDuplicatingSettingsCancel","render","comp","readablePath","getReadablePath","parentPath","section","content","map","item","index","childPath","concat","handleDeleteChildSectionOrQuestion","definedQuestions","handleSectionClick","d","duplicatingSettings","nu","slice","join","RootSection","questions","sections","name","getFromPath","root","el","length","addQuestion","i","current","Error","push","addSection","removeQuestion","questionId","parentSection","foundIndex","findIndex","splice","removeSection","sectionId","moveItem","prevPath","newPath","itemAtPath","newParentPath","oldParentPath","newParent","oldParent","removed","toJSON","a","r","mapValues","v","fromJSON","handleSectionAdd","hasOwnProperty","forEach","question"],"mappings":"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","sourcesContent":["import { ButtonGroup } from \"@blueprintjs/core\";\nimport { QuestionSection } from \"./SurveyForm\";\nimport { QAQuestion } from \"../form/question\";\nimport React from \"react\";\nimport { QuestionButton } from \"./questionButton\";\nimport { DPFormItem } from \"./DPFormItem\";\nimport { SectionButton } from \"./sectionButton\";\nimport { DuplicateSettings, IDupeSettings } from \"./duplicateSettings\";\nimport { getRandomId } from \"../utils/getRandomId\";\nimport _ from \"lodash\";\nimport { dupeSettingsFromJSON } from \"../utils/util\";\n\ninterface SectionCProps {\n    section: QuestionSection | RootSection,\n    definedQuestions: {[key:string]: QAQuestion}\n    handleQuestionChange: (question: QAQuestion, _path: number[]) => void,\n    parentPath: number[],\n    handleDeleteChildSectionOrQuestion: (deleteid: string, _path: number[]) => void,\n    handleSectionDuplicatingSettingsChange: (id: string, dupe: IDupeSettings) => void,\n    handleSectionClick: (sectionid: string, _path: number[]) => void,\n}\ninterface SectionCState {\n}\nexport class SectionC extends React.Component<SectionCProps, SectionCState>{\n    constructor(props: SectionCProps) {\n        super(props);\n        this.state = {\n        }\n    }\n\n    handleQuestionChange(q: QAQuestion, path: number[]) {\n        if (this.props.handleQuestionChange) this.props.handleQuestionChange(q, path);\n    }\n    handleDuplicatingSettingsSave(id: string, dupe: IDupeSettings) {\n        if (this.props.handleSectionDuplicatingSettingsChange) this.props.handleSectionDuplicatingSettingsChange(id, dupe)\n    }\n    handleDuplicatingSettingsCancel() {\n\n    }\n\n    render() {\n        let comp = null;\n        let readablePath = getReadablePath(this.props.parentPath);\n        if (readablePath) readablePath += \".\";\n        comp = this.props.section.content.map((item, index) => {\n            let childPath = this.props.parentPath.concat(index);\n            if (item instanceof QAQuestion) {\n                return <QuestionButton path={childPath} questionId={item.id} handleDeletion={this.props.handleDeleteChildSectionOrQuestion} readablePath={readablePath + (index + 1)} key={item.id} isExpanded={false}>\n                    <DPFormItem definedQuestions = {this.props.definedQuestions} onChange={(q) => this.handleQuestionChange(q, childPath)} question={item} />\n                </QuestionButton>\n            }\n            else if (item instanceof QuestionSection) {\n                return <SectionButton path={childPath} handleDeletion={this.props.handleDeleteChildSectionOrQuestion} sectionId={item.id} readablePath={readablePath + (index + 1)} key={item.id} onClick={this.props.handleSectionClick}>\n                    <DuplicateSettings definedQuestions={this.props.definedQuestions} handleSave={(d) => this.handleDuplicatingSettingsSave(item.id, d)} handleCancel={this.handleDuplicatingSettingsCancel} {...item.duplicatingSettings} />\n                </SectionButton>\n            }\n            return null;\n        })\n        return (\n            <ButtonGroup fill vertical>\n                {comp}\n\n            </ButtonGroup>\n\n        )\n    }\n}\n\n\n\nexport function getReadablePath(nu: number[]) {\n    return nu.slice(1).map(item => item + 1).join(\".\");\n\n}\n\n\nexport class RootSection {\n    questions: { [key: string]: QAQuestion } = {};\n    sections: { [key: string]: QuestionSection } = {};\n    content: (QuestionSection | QAQuestion)[] = [];\n    name!: string;\n    id: string;\n    constructor() {\n        this.id = getRandomId(\"root-\");\n    }\n\n    static getFromPath(path: number[], root: (RootSection | QuestionSection | QAQuestion)[]): RootSection | QuestionSection | QAQuestion {\n        let el = root[path[0]];\n        if (path.length === 1) return el;\n        return RootSection.getFromPath(path.slice(1), el.content)\n    }\n\n\n    addQuestion(parentPath: number[], q?: (QAQuestion)[]) {\n        if (!q) q = [new QAQuestion()];\n        let section = RootSection.getFromPath(parentPath, [this])\n        for (let i = 0; i < q.length; i++) {\n            let current = q[i];\n            if (this.questions[current.id]) throw new Error(\"Question id conflict\");\n            this.questions[current.id] = current;\n            if (!(section instanceof QAQuestion)) {\n                section.content.push(current);\n            }\n\n\n        }\n        return this;\n    }\n\n    addSection(parentPath: number[], q?: (QuestionSection)[]) {\n        if (!q) q = [new QuestionSection()];\n        let section = RootSection.getFromPath(parentPath, [this])\n        for (let i = 0; i < q.length; i++) {\n            let current = q[i];\n            if (this.questions[current.id]) throw new Error(\"Section id conflict\");\n            this.sections[current.id] = current;\n            if (!(section instanceof QAQuestion)) {\n                section.content.push(current);\n            }\n        }\n        return this;\n    }\n\n    removeQuestion(questionId: string, path: number[]) {\n        let parentSection = RootSection.getFromPath(path.slice(0, path.length - 1), [this]);\n        if (!(parentSection instanceof QAQuestion)) {\n            let foundIndex = parentSection.content.findIndex(item => item.id === questionId);\n            if (foundIndex > -1) {\n                parentSection.content.splice(foundIndex, 1);\n                delete this.questions[questionId];\n            }\n        }\n        return this;\n    }\n\n    removeSection(sectionId: string, path: number[]) {\n        let parentSection = RootSection.getFromPath(path.slice(0, path.length - 1), [this]);\n        if (!(parentSection instanceof QAQuestion)) {\n            let foundIndex = parentSection.content.findIndex(item => item.id === sectionId);\n            if (foundIndex > -1) {\n                parentSection.content.splice(foundIndex, 1);\n                delete this.sections[sectionId];\n            }\n        }\n        return this;\n    }\n\n    moveItem(prevPath: number[], newPath: number[]) {\n        let itemAtPath = RootSection.getFromPath(prevPath, [this]);\n        let newParentPath = newPath.slice(0, newPath.length - 1);\n        let oldParentPath = prevPath.slice(0, prevPath.length - 1);\n        let newParent = RootSection.getFromPath(newParentPath, [this]);\n        let oldParent = RootSection.getFromPath(oldParentPath, [this]);\n        let foundIndex = oldParent.content.findIndex(item => item.id === itemAtPath.id);\n        if (foundIndex > -1 && !(oldParent instanceof QAQuestion)) {\n            let removed = oldParent.content.splice(foundIndex, 1);\n\n            if (!(newParent instanceof QAQuestion)) {\n                if (removed instanceof QuestionSection) {\n                    newParent.content.push(this.sections[removed[0].id]);\n                }\n                else if (removed instanceof QAQuestion) {\n                    newParent.content.push(this.sections[removed[0].id])\n                }\n            }\n            return this;\n        }\n\n    }\n    static toJSON(a: RootSection) {\n        let r = {\n            id: a.id,\n            name: a.name,\n            content: a.content.map(item => {\n                if (item instanceof QuestionSection) {\n                    return QuestionSection.toJSON(item);\n                }\n                else if (item instanceof QAQuestion) {\n                    return QAQuestion.toJSON(item);\n                }\n            }),\n            questions: _.mapValues(a.questions, (v) => QAQuestion.toJSON(v)),\n            sections: _.mapValues(a.sections, (v) => QuestionSection.toJSON(v))\n\n        };\n        return r;\n    }\n\n    static fromJSON(a: any): RootSection {\n        let r = new RootSection();\n        let path = [0];\n        const handleSectionAdd = (a: any, parentPath: number[], index: number) => {\n            if (a.hasOwnProperty(\"content\")) {\n                let section = new QuestionSection();\n                section.id = a.id;\n                section.duplicatingSettings = dupeSettingsFromJSON(a.duplicatingSettings);\n                r.addSection(parentPath, [section]);\n                a.content.forEach((item: any, i: number) => handleSectionAdd(item, parentPath.concat(index), i));\n            }\n            else {\n                let question = QAQuestion.fromJSON(a);\n                r.addQuestion(parentPath, [question]);\n            }\n        }\n        a.content.forEach((item: any, index: number) => handleSectionAdd(item, path, index))\n        return r;\n    }\n}"]},"metadata":{},"sourceType":"module"}