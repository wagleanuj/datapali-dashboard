{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { AbstractPureComponent, Boundary, DISPLAYNAME_PREFIX, Divider, Utils } from \"@blueprintjs/core\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport DayPicker from \"react-day-picker\";\nimport * as DateClasses from \"./common/classes\";\nimport * as DateUtils from \"./common/dateUtils\";\nimport * as Errors from \"./common/errors\";\nimport { MonthAndYear } from \"./common/monthAndYear\";\nimport { DatePickerCaption } from \"./datePickerCaption\";\nimport { combineModifiers, getDefaultMaxDate, getDefaultMinDate, HOVERED_RANGE_MODIFIER, SELECTED_RANGE_MODIFIER } from \"./datePickerCore\";\nimport { DatePickerNavbar } from \"./datePickerNavbar\";\nimport { DateRangeSelectionStrategy } from \"./dateRangeSelectionStrategy\";\nimport { Shortcuts } from \"./shortcuts\";\nimport { TimePicker } from \"./timePicker\";\n\nvar DateRangePicker =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(DateRangePicker, _super);\n\n  function DateRangePicker(props, context) {\n    var _this = _super.call(this, props, context) || this; // these will get merged with the user's own\n\n\n    _this.modifiers = (_a = {}, _a[SELECTED_RANGE_MODIFIER] = function (day) {\n      var value = _this.state.value;\n      return value[0] != null && value[1] != null && DateUtils.isDayInRange(day, value, true);\n    }, _a[SELECTED_RANGE_MODIFIER + \"-start\"] = function (day) {\n      return DateUtils.areSameDay(_this.state.value[0], day);\n    }, _a[SELECTED_RANGE_MODIFIER + \"-end\"] = function (day) {\n      return DateUtils.areSameDay(_this.state.value[1], day);\n    }, _a[HOVERED_RANGE_MODIFIER] = function (day) {\n      var _a = _this.state,\n          hoverValue = _a.hoverValue,\n          _b = _a.value,\n          selectedStart = _b[0],\n          selectedEnd = _b[1];\n\n      if (selectedStart == null && selectedEnd == null) {\n        return false;\n      }\n\n      if (hoverValue == null || hoverValue[0] == null || hoverValue[1] == null) {\n        return false;\n      }\n\n      return DateUtils.isDayInRange(day, hoverValue, true);\n    }, _a[HOVERED_RANGE_MODIFIER + \"-start\"] = function (day) {\n      var hoverValue = _this.state.hoverValue;\n\n      if (hoverValue == null || hoverValue[0] == null) {\n        return false;\n      }\n\n      return DateUtils.areSameDay(hoverValue[0], day);\n    }, _a[HOVERED_RANGE_MODIFIER + \"-end\"] = function (day) {\n      var hoverValue = _this.state.hoverValue;\n\n      if (hoverValue == null || hoverValue[1] == null) {\n        return false;\n      }\n\n      return DateUtils.areSameDay(hoverValue[1], day);\n    }, _a);\n\n    _this.disabledDays = function (day) {\n      return !DateUtils.isDayInRange(day, [_this.props.minDate, _this.props.maxDate]);\n    };\n\n    _this.getDisabledDaysModifier = function () {\n      var disabledDays = _this.props.dayPickerProps.disabledDays;\n      return disabledDays instanceof Array ? [_this.disabledDays].concat(disabledDays) : [_this.disabledDays, disabledDays];\n    };\n\n    _this.handleTimeChange = function (newTime, dateIndex) {\n      Utils.safeInvoke(_this.props.timePickerProps.onChange, newTime);\n      var _a = _this.state,\n          value = _a.value,\n          time = _a.time;\n      var newValue = DateUtils.getDateTime(value[dateIndex] != null ? DateUtils.clone(value[dateIndex]) : new Date(), newTime);\n      var newDateRange = [value[0], value[1]];\n      newDateRange[dateIndex] = newValue;\n      var newTimeRange = [time[0], time[1]];\n      newTimeRange[dateIndex] = newTime;\n      Utils.safeInvoke(_this.props.onChange, newDateRange);\n\n      _this.setState({\n        value: newDateRange,\n        time: newTimeRange\n      });\n    };\n\n    _this.handleTimeChangeLeftCalendar = function (time) {\n      _this.handleTimeChange(time, 0);\n    };\n\n    _this.handleTimeChangeRightCalendar = function (time) {\n      _this.handleTimeChange(time, 1);\n    };\n\n    _this.renderSingleNavbar = function (navbarProps) {\n      return React.createElement(DatePickerNavbar, tslib_1.__assign({}, navbarProps, {\n        maxDate: _this.props.maxDate,\n        minDate: _this.props.minDate\n      }));\n    };\n\n    _this.renderLeftNavbar = function (navbarProps) {\n      return React.createElement(DatePickerNavbar, tslib_1.__assign({}, navbarProps, {\n        hideRightNavButton: _this.props.contiguousCalendarMonths,\n        maxDate: _this.props.maxDate,\n        minDate: _this.props.minDate\n      }));\n    };\n\n    _this.renderRightNavbar = function (navbarProps) {\n      return React.createElement(DatePickerNavbar, tslib_1.__assign({}, navbarProps, {\n        hideLeftNavButton: _this.props.contiguousCalendarMonths,\n        maxDate: _this.props.maxDate,\n        minDate: _this.props.minDate\n      }));\n    };\n\n    _this.renderSingleCaption = function (captionProps) {\n      return React.createElement(DatePickerCaption, tslib_1.__assign({}, captionProps, {\n        maxDate: _this.props.maxDate,\n        minDate: _this.props.minDate,\n        onMonthChange: _this.handleLeftMonthSelectChange,\n        onYearChange: _this.handleLeftYearSelectChange,\n        reverseMonthAndYearMenus: _this.props.reverseMonthAndYearMenus\n      }));\n    };\n\n    _this.renderLeftCaption = function (captionProps) {\n      return React.createElement(DatePickerCaption, tslib_1.__assign({}, captionProps, {\n        maxDate: DateUtils.getDatePreviousMonth(_this.props.maxDate),\n        minDate: _this.props.minDate,\n        onMonthChange: _this.handleLeftMonthSelectChange,\n        onYearChange: _this.handleLeftYearSelectChange,\n        reverseMonthAndYearMenus: _this.props.reverseMonthAndYearMenus\n      }));\n    };\n\n    _this.renderRightCaption = function (captionProps) {\n      return React.createElement(DatePickerCaption, tslib_1.__assign({}, captionProps, {\n        maxDate: _this.props.maxDate,\n        minDate: DateUtils.getDateNextMonth(_this.props.minDate),\n        onMonthChange: _this.handleRightMonthSelectChange,\n        onYearChange: _this.handleRightYearSelectChange,\n        reverseMonthAndYearMenus: _this.props.reverseMonthAndYearMenus\n      }));\n    };\n\n    _this.handleDayMouseEnter = function (day, modifiers, e) {\n      Utils.safeInvoke(_this.props.dayPickerProps.onDayMouseEnter, day, modifiers, e);\n\n      if (modifiers.disabled) {\n        return;\n      }\n\n      var _a = DateRangeSelectionStrategy.getNextState(_this.state.value, day, _this.props.allowSingleDayRange, _this.props.boundaryToModify),\n          dateRange = _a.dateRange,\n          boundary = _a.boundary;\n\n      _this.setState({\n        hoverValue: dateRange\n      });\n\n      Utils.safeInvoke(_this.props.onHoverChange, dateRange, day, boundary);\n    };\n\n    _this.handleDayMouseLeave = function (day, modifiers, e) {\n      Utils.safeInvoke(_this.props.dayPickerProps.onDayMouseLeave, day, modifiers, e);\n\n      if (modifiers.disabled) {\n        return;\n      }\n\n      _this.setState({\n        hoverValue: undefined\n      });\n\n      Utils.safeInvoke(_this.props.onHoverChange, undefined, day, undefined);\n    };\n\n    _this.handleDayClick = function (day, modifiers, e) {\n      Utils.safeInvoke(_this.props.dayPickerProps.onDayClick, day, modifiers, e);\n\n      if (modifiers.disabled) {\n        // rerender base component to get around bug where you can navigate past bounds by clicking days\n        _this.forceUpdate();\n\n        return;\n      }\n\n      var nextValue = DateRangeSelectionStrategy.getNextState(_this.state.value, day, _this.props.allowSingleDayRange, _this.props.boundaryToModify).dateRange; // update the hovered date range after click to show the newly selected\n      // state, at leasts until the mouse moves again\n\n      _this.handleDayMouseEnter(day, modifiers, e);\n\n      _this.handleNextState(nextValue);\n    };\n\n    _this.handleShortcutClick = function (shortcut) {\n      var dateRange = shortcut.dateRange,\n          includeTime = shortcut.includeTime;\n\n      if (includeTime) {\n        var newDateRange = [dateRange[0], dateRange[1]];\n        var newTimeRange = [dateRange[0], dateRange[1]];\n        var nextState = getStateChange(_this.state.value, dateRange, _this.state, _this.props.contiguousCalendarMonths);\n\n        _this.setState(tslib_1.__assign({}, nextState, {\n          time: newTimeRange\n        }));\n\n        Utils.safeInvoke(_this.props.onChange, newDateRange);\n      } else {\n        _this.handleNextState(dateRange);\n      }\n    };\n\n    _this.handleNextState = function (nextValue) {\n      var value = _this.state.value;\n      nextValue[0] = DateUtils.getDateTime(nextValue[0], _this.state.time[0]);\n      nextValue[1] = DateUtils.getDateTime(nextValue[1], _this.state.time[1]);\n      var nextState = getStateChange(value, nextValue, _this.state, _this.props.contiguousCalendarMonths);\n\n      if (_this.props.value == null) {\n        _this.setState(nextState);\n      }\n\n      Utils.safeInvoke(_this.props.onChange, nextValue);\n    };\n\n    _this.handleLeftMonthChange = function (newDate) {\n      var leftView = MonthAndYear.fromDate(newDate);\n      Utils.safeInvoke(_this.props.dayPickerProps.onMonthChange, leftView.getFullDate());\n\n      _this.updateLeftView(leftView);\n    };\n\n    _this.handleRightMonthChange = function (newDate) {\n      var rightView = MonthAndYear.fromDate(newDate);\n      Utils.safeInvoke(_this.props.dayPickerProps.onMonthChange, rightView.getFullDate());\n\n      _this.updateRightView(rightView);\n    };\n\n    _this.handleLeftMonthSelectChange = function (leftMonth) {\n      var leftView = new MonthAndYear(leftMonth, _this.state.leftView.getYear());\n      Utils.safeInvoke(_this.props.dayPickerProps.onMonthChange, leftView.getFullDate());\n\n      _this.updateLeftView(leftView);\n    };\n\n    _this.handleRightMonthSelectChange = function (rightMonth) {\n      var rightView = new MonthAndYear(rightMonth, _this.state.rightView.getYear());\n      Utils.safeInvoke(_this.props.dayPickerProps.onMonthChange, rightView.getFullDate());\n\n      _this.updateRightView(rightView);\n    };\n    /*\n     * The min / max months are offset by one because we are showing two months.\n     * We do a comparison check to see if\n     *   a) the proposed [Month, Year] change throws the two calendars out of order\n     *   b) the proposed [Month, Year] goes beyond the min / max months\n     * and rectify appropriately.\n     */\n\n\n    _this.handleLeftYearSelectChange = function (leftDisplayYear) {\n      var leftView = new MonthAndYear(_this.state.leftView.getMonth(), leftDisplayYear);\n      Utils.safeInvoke(_this.props.dayPickerProps.onMonthChange, leftView.getFullDate());\n      var _a = _this.props,\n          minDate = _a.minDate,\n          maxDate = _a.maxDate;\n      var adjustedMaxDate = DateUtils.getDatePreviousMonth(maxDate);\n      var minMonthAndYear = new MonthAndYear(minDate.getMonth(), minDate.getFullYear());\n      var maxMonthAndYear = new MonthAndYear(adjustedMaxDate.getMonth(), adjustedMaxDate.getFullYear());\n\n      if (leftView.isBefore(minMonthAndYear)) {\n        leftView = minMonthAndYear;\n      } else if (leftView.isAfter(maxMonthAndYear)) {\n        leftView = maxMonthAndYear;\n      }\n\n      var rightView = _this.state.rightView.clone();\n\n      if (!leftView.isBefore(rightView) || _this.props.contiguousCalendarMonths) {\n        rightView = leftView.getNextMonth();\n      }\n\n      _this.setViews(leftView, rightView);\n    };\n\n    _this.handleRightYearSelectChange = function (rightDisplayYear) {\n      var rightView = new MonthAndYear(_this.state.rightView.getMonth(), rightDisplayYear);\n      Utils.safeInvoke(_this.props.dayPickerProps.onMonthChange, rightView.getFullDate());\n      var _a = _this.props,\n          minDate = _a.minDate,\n          maxDate = _a.maxDate;\n      var adjustedMinDate = DateUtils.getDateNextMonth(minDate);\n      var minMonthAndYear = MonthAndYear.fromDate(adjustedMinDate);\n      var maxMonthAndYear = MonthAndYear.fromDate(maxDate);\n\n      if (rightView.isBefore(minMonthAndYear)) {\n        rightView = minMonthAndYear;\n      } else if (rightView.isAfter(maxMonthAndYear)) {\n        rightView = maxMonthAndYear;\n      }\n\n      var leftView = _this.state.leftView.clone();\n\n      if (!rightView.isAfter(leftView) || _this.props.contiguousCalendarMonths) {\n        leftView = rightView.getPreviousMonth();\n      }\n\n      _this.setViews(leftView, rightView);\n    };\n\n    var value = getInitialValue(props);\n    var time = value;\n    var initialMonth = getInitialMonth(props, value); // if the initial month is the last month of the picker's\n    // allowable range, the react-day-picker library will show\n    // the max month on the left and the *min* month on the right.\n    // subtracting one avoids that weird, wraparound state (#289).\n\n    var initialMonthEqualsMinMonth = DateUtils.areSameMonth(initialMonth, props.minDate);\n    var initalMonthEqualsMaxMonth = DateUtils.areSameMonth(initialMonth, props.maxDate);\n\n    if (!props.singleMonthOnly && !initialMonthEqualsMinMonth && initalMonthEqualsMaxMonth) {\n      initialMonth.setMonth(initialMonth.getMonth() - 1);\n    } // show the selected end date's encompassing month in the right view if\n    // the calendars don't have to be contiguous.\n    // if left view and right view months are the same, show next month in the right view.\n\n\n    var leftView = MonthAndYear.fromDate(initialMonth);\n    var rightDate = value[1];\n    var rightView = !props.contiguousCalendarMonths && rightDate != null && !DateUtils.areSameMonth(initialMonth, rightDate) ? MonthAndYear.fromDate(rightDate) : leftView.getNextMonth();\n    _this.state = {\n      leftView: leftView,\n      rightView: rightView,\n      value: value,\n      hoverValue: [null, null],\n      time: time\n    };\n    return _this;\n\n    var _a;\n  }\n\n  DateRangePicker.prototype.render = function () {\n    var _a = this.props,\n        className = _a.className,\n        contiguousCalendarMonths = _a.contiguousCalendarMonths,\n        singleMonthOnly = _a.singleMonthOnly;\n    var isShowingOneMonth = singleMonthOnly || DateUtils.areSameMonth(this.props.minDate, this.props.maxDate);\n    var classes = classNames(DateClasses.DATEPICKER, DateClasses.DATERANGEPICKER, className, (_b = {}, _b[DateClasses.DATERANGEPICKER_CONTIGUOUS] = contiguousCalendarMonths, _b[DateClasses.DATERANGEPICKER_SINGLE_MONTH] = isShowingOneMonth, _b)); // use the left DayPicker when we only need one\n\n    return React.createElement(\"div\", {\n      className: classes\n    }, this.maybeRenderShortcuts(), React.createElement(\"div\", null, this.renderCalendars(isShowingOneMonth), this.maybeRenderTimePickers()));\n\n    var _b;\n  };\n\n  DateRangePicker.prototype.componentWillReceiveProps = function (nextProps) {\n    _super.prototype.componentWillReceiveProps.call(this, nextProps);\n\n    if (!DateUtils.areRangesEqual(this.props.value, nextProps.value) || this.props.contiguousCalendarMonths !== nextProps.contiguousCalendarMonths) {\n      var nextState = getStateChange(this.props.value, nextProps.value, this.state, nextProps.contiguousCalendarMonths);\n      this.setState(nextState);\n    }\n  };\n\n  DateRangePicker.prototype.validateProps = function (props) {\n    var defaultValue = props.defaultValue,\n        initialMonth = props.initialMonth,\n        maxDate = props.maxDate,\n        minDate = props.minDate,\n        boundaryToModify = props.boundaryToModify,\n        value = props.value;\n    var dateRange = [minDate, maxDate];\n\n    if (defaultValue != null && !DateUtils.isDayRangeInRange(defaultValue, dateRange)) {\n      throw new Error(Errors.DATERANGEPICKER_DEFAULT_VALUE_INVALID);\n    }\n\n    if (initialMonth != null && !DateUtils.isMonthInRange(initialMonth, dateRange)) {\n      throw new Error(Errors.DATERANGEPICKER_INITIAL_MONTH_INVALID);\n    }\n\n    if (maxDate != null && minDate != null && maxDate < minDate && !DateUtils.areSameDay(maxDate, minDate)) {\n      throw new Error(Errors.DATERANGEPICKER_MAX_DATE_INVALID);\n    }\n\n    if (value != null && !DateUtils.isDayRangeInRange(value, dateRange)) {\n      throw new Error(Errors.DATERANGEPICKER_VALUE_INVALID);\n    }\n\n    if (boundaryToModify != null && boundaryToModify !== Boundary.START && boundaryToModify !== Boundary.END) {\n      throw new Error(Errors.DATERANGEPICKER_PREFERRED_BOUNDARY_TO_MODIFY_INVALID);\n    }\n  };\n\n  DateRangePicker.prototype.maybeRenderShortcuts = function () {\n    var shortcuts = this.props.shortcuts;\n\n    if (shortcuts == null || shortcuts === false) {\n      return null;\n    }\n\n    var _a = this.props,\n        allowSingleDayRange = _a.allowSingleDayRange,\n        maxDate = _a.maxDate,\n        minDate = _a.minDate,\n        timePrecision = _a.timePrecision;\n    return [React.createElement(Shortcuts, tslib_1.__assign({\n      key: \"shortcuts\"\n    }, {\n      allowSingleDayRange: allowSingleDayRange,\n      maxDate: maxDate,\n      minDate: minDate,\n      shortcuts: shortcuts,\n      timePrecision: timePrecision\n    }, {\n      onShortcutClick: this.handleShortcutClick\n    })), React.createElement(Divider, {\n      key: \"div\"\n    })];\n  };\n\n  DateRangePicker.prototype.maybeRenderTimePickers = function () {\n    var _a = this.props,\n        timePrecision = _a.timePrecision,\n        timePickerProps = _a.timePickerProps;\n\n    if (timePrecision == null && timePickerProps === DateRangePicker.defaultProps.timePickerProps) {\n      return null;\n    }\n\n    return React.createElement(\"div\", {\n      className: DateClasses.DATERANGEPICKER_TIMEPICKERS\n    }, React.createElement(TimePicker, tslib_1.__assign({\n      precision: timePrecision\n    }, timePickerProps, {\n      onChange: this.handleTimeChangeLeftCalendar,\n      value: this.state.time[0]\n    })), React.createElement(TimePicker, tslib_1.__assign({\n      precision: timePrecision\n    }, timePickerProps, {\n      onChange: this.handleTimeChangeRightCalendar,\n      value: this.state.time[1]\n    })));\n  };\n\n  DateRangePicker.prototype.renderCalendars = function (isShowingOneMonth) {\n    var _a = this.props,\n        dayPickerProps = _a.dayPickerProps,\n        locale = _a.locale,\n        localeUtils = _a.localeUtils,\n        maxDate = _a.maxDate,\n        minDate = _a.minDate;\n\n    var dayPickerBaseProps = tslib_1.__assign({\n      locale: locale,\n      localeUtils: localeUtils,\n      modifiers: combineModifiers(this.modifiers, this.props.modifiers),\n      showOutsideDays: true\n    }, dayPickerProps, {\n      disabledDays: this.getDisabledDaysModifier(),\n      onDayClick: this.handleDayClick,\n      onDayMouseEnter: this.handleDayMouseEnter,\n      onDayMouseLeave: this.handleDayMouseLeave,\n      selectedDays: this.state.value\n    });\n\n    if (isShowingOneMonth) {\n      return React.createElement(DayPicker, tslib_1.__assign({}, dayPickerBaseProps, {\n        captionElement: this.renderSingleCaption,\n        navbarElement: this.renderSingleNavbar,\n        fromMonth: minDate,\n        month: this.state.leftView.getFullDate(),\n        numberOfMonths: 1,\n        onMonthChange: this.handleLeftMonthChange,\n        toMonth: maxDate\n      }));\n    } else {\n      return [React.createElement(DayPicker, tslib_1.__assign({\n        key: \"left\"\n      }, dayPickerBaseProps, {\n        canChangeMonth: true,\n        captionElement: this.renderLeftCaption,\n        navbarElement: this.renderLeftNavbar,\n        fromMonth: minDate,\n        month: this.state.leftView.getFullDate(),\n        numberOfMonths: 1,\n        onMonthChange: this.handleLeftMonthChange,\n        toMonth: DateUtils.getDatePreviousMonth(maxDate)\n      })), React.createElement(DayPicker, tslib_1.__assign({\n        key: \"right\"\n      }, dayPickerBaseProps, {\n        canChangeMonth: true,\n        captionElement: this.renderRightCaption,\n        navbarElement: this.renderRightNavbar,\n        fromMonth: DateUtils.getDateNextMonth(minDate),\n        month: this.state.rightView.getFullDate(),\n        numberOfMonths: 1,\n        onMonthChange: this.handleRightMonthChange,\n        toMonth: maxDate\n      }))];\n    }\n  };\n\n  DateRangePicker.prototype.updateLeftView = function (leftView) {\n    var rightView = this.state.rightView.clone();\n\n    if (!leftView.isBefore(rightView) || this.props.contiguousCalendarMonths) {\n      rightView = leftView.getNextMonth();\n    }\n\n    this.setViews(leftView, rightView);\n  };\n\n  DateRangePicker.prototype.updateRightView = function (rightView) {\n    var leftView = this.state.leftView.clone();\n\n    if (!rightView.isAfter(leftView) || this.props.contiguousCalendarMonths) {\n      leftView = rightView.getPreviousMonth();\n    }\n\n    this.setViews(leftView, rightView);\n  };\n\n  DateRangePicker.prototype.setViews = function (leftView, rightView) {\n    this.setState({\n      leftView: leftView,\n      rightView: rightView\n    });\n  };\n\n  DateRangePicker.defaultProps = {\n    allowSingleDayRange: false,\n    contiguousCalendarMonths: true,\n    dayPickerProps: {},\n    maxDate: getDefaultMaxDate(),\n    minDate: getDefaultMinDate(),\n    reverseMonthAndYearMenus: false,\n    shortcuts: true,\n    singleMonthOnly: false,\n    timePickerProps: {}\n  };\n  DateRangePicker.displayName = DISPLAYNAME_PREFIX + \".DateRangePicker\";\n  return DateRangePicker;\n}(AbstractPureComponent);\n\nexport { DateRangePicker };\n\nfunction getStateChange(value, nextValue, state, contiguousCalendarMonths) {\n  if (value != null && nextValue == null) {\n    return {\n      value: [null, null]\n    };\n  } else if (nextValue != null) {\n    var leftView = state.leftView.clone();\n    var rightView = state.rightView.clone();\n    var nextValueStartView = MonthAndYear.fromDate(nextValue[0]);\n    var nextValueEndView = MonthAndYear.fromDate(nextValue[1]); // Only end date selected.\n    // If the newly selected end date isn't in either of the displayed months, then\n    //   - set the right DayPicker to the month of the selected end date\n    //   - ensure the left DayPicker is before the right, changing if needed\n\n    if (nextValueStartView == null && nextValueEndView != null) {\n      if (!nextValueEndView.isSame(leftView) && !nextValueEndView.isSame(rightView)) {\n        rightView = nextValueEndView;\n\n        if (!leftView.isBefore(rightView)) {\n          leftView = rightView.getPreviousMonth();\n        }\n      }\n    } else if (nextValueStartView != null && nextValueEndView == null) {\n      // Only start date selected.\n      // If the newly selected start date isn't in either of the displayed months, then\n      //   - set the left DayPicker to the month of the selected start date\n      //   - ensure the right DayPicker is before the left, changing if needed\n      if (!nextValueStartView.isSame(leftView) && !nextValueStartView.isSame(rightView)) {\n        leftView = nextValueStartView;\n\n        if (!rightView.isAfter(leftView)) {\n          rightView = leftView.getNextMonth();\n        }\n      }\n    } else if (nextValueStartView != null && nextValueEndView != null) {\n      // Both start and end date months are identical\n      // If the selected month isn't in either of the displayed months, then\n      //   - set the left DayPicker to be the selected month\n      //   - set the right DayPicker to +1\n      if (nextValueStartView.isSameMonth(nextValueEndView)) {\n        if (leftView.isSame(nextValueStartView) || rightView.isSame(nextValueStartView)) {// do nothing\n        } else {\n          leftView = nextValueStartView;\n          rightView = nextValueStartView.getNextMonth();\n        }\n      } else {\n        // Different start and end date months, adjust display months.\n        if (!leftView.isSame(nextValueStartView)) {\n          leftView = nextValueStartView;\n          rightView = nextValueStartView.getNextMonth();\n        }\n\n        if (contiguousCalendarMonths === false && !rightView.isSame(nextValueEndView)) {\n          rightView = nextValueEndView;\n        }\n      }\n    }\n\n    return {\n      leftView: leftView,\n      rightView: rightView,\n      value: nextValue\n    };\n  } else if (contiguousCalendarMonths === true) {\n    // contiguousCalendarMonths is toggled on.\n    // If the previous leftView and rightView are not contiguous, then set the right DayPicker to left + 1\n    if (!state.leftView.getNextMonth().isSameMonth(state.rightView)) {\n      var nextRightView = state.leftView.getNextMonth();\n      return {\n        rightView: nextRightView\n      };\n    }\n  }\n\n  return {};\n}\n\nfunction getInitialValue(props) {\n  if (props.value != null) {\n    return props.value;\n  }\n\n  if (props.defaultValue != null) {\n    return props.defaultValue;\n  }\n\n  return [null, null];\n}\n\nfunction getInitialMonth(props, value) {\n  var today = new Date(); // != because we must have a real `Date` to begin the calendar on.\n\n  if (props.initialMonth != null) {\n    return props.initialMonth;\n  } else if (value[0] != null) {\n    return DateUtils.clone(value[0]);\n  } else if (value[1] != null) {\n    var month = DateUtils.clone(value[1]);\n\n    if (!DateUtils.areSameMonth(month, props.minDate)) {\n      month.setMonth(month.getMonth() - 1);\n    }\n\n    return month;\n  } else if (DateUtils.isDayInRange(today, [props.minDate, props.maxDate])) {\n    return today;\n  } else {\n    return DateUtils.getDateBetween([props.minDate, props.maxDate]);\n  }\n}","map":null,"metadata":{},"sourceType":"module"}