{"ast":null,"code":"import _ from \"lodash\";\nexport class QACondition {\n  constructor() {\n    this.literals = void 0;\n    this.literals = Array();\n  }\n\n  static fromJSON(data) {\n    if (!data) return new QACondition();\n    let c = new QACondition();\n    let literals = data.literals;\n    c.setLiterals(literals);\n    return c;\n  }\n\n  static toJSON(data) {\n    if (!data) return undefined;\n    return {\n      literals: JSON.parse(JSON.stringify(data.literals))\n    };\n  }\n\n  static checkIfValid(condition) {\n    if (!condition.literals) return false;\n    let isValid = true;\n    condition.literals.forEach(literal => {\n      let validity = Object.values(literal).every(x => !_.isNil(x));\n      if (!validity) isValid = false;\n    });\n    console.log(isValid);\n    return isValid;\n  }\n\n  static Clone(condition) {\n    let newCondition = new QACondition();\n    return newCondition;\n  }\n\n  setLiterals(newLiterals) {\n    this.literals = newLiterals;\n    return this;\n  }\n\n  getClause() {\n    let clause = \"\";\n    this.literals.forEach((literal, key) => {\n      clause += \"l\".concat(key).concat(key === this.literals.length - 1 ? literal.followingOperator : \"\");\n    });\n    return clause;\n  }\n\n  get Literals() {\n    return this.literals;\n  }\n\n  addLiteral(literal) {\n    this.literals.push(literal);\n    console.log(this.literals);\n  }\n\n  deleteLiteral(literalIndex) {\n    this.literals.splice(literalIndex, 1);\n    return this;\n  }\n\n}\nexport let QAFollowingOperator;\n\n(function (QAFollowingOperator) {\n  QAFollowingOperator[\"OR\"] = \"||\";\n  QAFollowingOperator[\"AND\"] = \"&\";\n})(QAFollowingOperator || (QAFollowingOperator = {}));","map":{"version":3,"sources":["/Users/anujwagle/Desktop/temp/datapali-dashboard/src/form/condition.ts"],"names":["_","QACondition","constructor","literals","Array","fromJSON","data","c","setLiterals","toJSON","undefined","JSON","parse","stringify","checkIfValid","condition","isValid","forEach","literal","validity","Object","values","every","x","isNil","console","log","Clone","newCondition","newLiterals","getClause","clause","key","length","followingOperator","Literals","addLiteral","push","deleteLiteral","literalIndex","splice","QAFollowingOperator"],"mappings":"AACA,OAAOA,CAAP,MAAc,QAAd;AAEA,OAAO,MAAMC,WAAN,CAAkB;AAIrBC,EAAAA,WAAW,GAAG;AAAA,SAFdC,QAEc;AACV,SAAKA,QAAL,GAAgBC,KAAK,EAArB;AACH;;AAED,SAAOC,QAAP,CAAgBC,IAAhB,EAA8C;AAC1C,QAAG,CAACA,IAAJ,EAAU,OAAO,IAAIL,WAAJ,EAAP;AACV,QAAIM,CAAC,GAAG,IAAIN,WAAJ,EAAR;AACA,QAAIE,QAAoB,GAAGG,IAAI,CAACH,QAAhC;AACAI,IAAAA,CAAC,CAACC,WAAF,CAAcL,QAAd;AACA,WAAOI,CAAP;AACH;;AAED,SAAOE,MAAP,CAAcH,IAAd,EAAsE;AAClE,QAAI,CAACA,IAAL,EAAW,OAAOI,SAAP;AACX,WAAO;AACHP,MAAAA,QAAQ,EAAEQ,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAeP,IAAI,CAACH,QAApB,CAAX;AADP,KAAP;AAGH;;AAED,SAAOW,YAAP,CAAoBC,SAApB,EAA4C;AACxC,QAAI,CAACA,SAAS,CAACZ,QAAf,EAAyB,OAAO,KAAP;AACzB,QAAIa,OAAO,GAAG,IAAd;AACAD,IAAAA,SAAS,CAACZ,QAAV,CAAmBc,OAAnB,CAA4BC,OAAD,IAAa;AACpC,UAAIC,QAAiB,GAAGC,MAAM,CAACC,MAAP,CAAcH,OAAd,EAAuBI,KAAvB,CAA8BC,CAAD,IAAiB,CAACvB,CAAC,CAACwB,KAAF,CAAQD,CAAR,CAA/C,CAAxB;AACA,UAAI,CAACJ,QAAL,EAAeH,OAAO,GAAG,KAAV;AAClB,KAHD;AAIAS,IAAAA,OAAO,CAACC,GAAR,CAAYV,OAAZ;AACA,WAAOA,OAAP;AAEH;;AAED,SAAOW,KAAP,CAAaZ,SAAb,EAAkD;AAC9C,QAAIa,YAAY,GAAG,IAAI3B,WAAJ,EAAnB;AACA,WAAO2B,YAAP;AACH;;AACDpB,EAAAA,WAAW,CAACqB,WAAD,EAA0B;AACjC,SAAK1B,QAAL,GAAgB0B,WAAhB;AACA,WAAO,IAAP;AACH;;AAEDC,EAAAA,SAAS,GAAW;AAChB,QAAIC,MAAM,GAAG,EAAb;AACA,SAAK5B,QAAL,CAAcc,OAAd,CAAsB,CAACC,OAAD,EAAUc,GAAV,KAAkB;AACpCD,MAAAA,MAAM,eAAQC,GAAR,SAAcA,GAAG,KAAK,KAAK7B,QAAL,CAAc8B,MAAd,GAAuB,CAA/B,GAAmCf,OAAO,CAACgB,iBAA3C,GAA+D,EAA7E,CAAN;AACH,KAFD;AAGA,WAAOH,MAAP;AACH;;AAED,MAAII,QAAJ,GAAgC;AAC5B,WAAO,KAAKhC,QAAZ;AACH;;AAEDiC,EAAAA,UAAU,CAAClB,OAAD,EAAoB;AAC1B,SAAKf,QAAL,CAAckC,IAAd,CAAmBnB,OAAnB;AACAO,IAAAA,OAAO,CAACC,GAAR,CAAY,KAAKvB,QAAjB;AACH;;AAEDmC,EAAAA,aAAa,CAACC,YAAD,EAAuB;AAChC,SAAKpC,QAAL,CAAcqC,MAAd,CAAqBD,YAArB,EAAmC,CAAnC;AACA,WAAO,IAAP;AACH;;AAhEoB;AAsEzB,WAAYE,mBAAZ;;WAAYA,mB;AAAAA,EAAAA,mB;AAAAA,EAAAA,mB;GAAAA,mB,KAAAA,mB","sourcesContent":["import { ILiteral } from \"./answer\";\r\nimport _ from \"lodash\";\r\n\r\nexport class QACondition {\r\n\r\n    literals: Array<ILiteral>;\r\n\r\n    constructor() {\r\n        this.literals = Array<ILiteral>();\r\n    }\r\n\r\n    static fromJSON(data: { [key: string]: any }) {\r\n        if(!data) return new QACondition();\r\n        let c = new QACondition();\r\n        let literals: ILiteral[] = data.literals;\r\n        c.setLiterals(literals)\r\n        return c;\r\n    }\r\n\r\n    static toJSON(data?: QACondition): { [key: string]: any } | undefined {\r\n        if (!data) return undefined;\r\n        return {\r\n            literals: JSON.parse(JSON.stringify(data.literals))\r\n        }\r\n    }\r\n\r\n    static checkIfValid(condition: QACondition) {\r\n        if (!condition.literals) return false;\r\n        let isValid = true;\r\n        condition.literals.forEach((literal) => {\r\n            let validity: boolean = Object.values(literal).every((x: ILiteral) => !_.isNil(x));\r\n            if (!validity) isValid = false;\r\n        });\r\n        console.log(isValid);\r\n        return isValid;\r\n\r\n    }\r\n\r\n    static Clone(condition: QACondition): QACondition {\r\n        let newCondition = new QACondition();\r\n        return newCondition;\r\n    }\r\n    setLiterals(newLiterals: ILiteral[]) {\r\n        this.literals = newLiterals;\r\n        return this;\r\n    }\r\n\r\n    getClause(): string {\r\n        let clause = \"\";\r\n        this.literals.forEach((literal, key) => {\r\n            clause += `l${key}${key === this.literals.length - 1 ? literal.followingOperator : \"\"}`\r\n        });\r\n        return clause;\r\n    }\r\n\r\n    get Literals(): Array<ILiteral> {\r\n        return this.literals;\r\n    }\r\n\r\n    addLiteral(literal: ILiteral) {\r\n        this.literals.push(literal);\r\n        console.log(this.literals);\r\n    }\r\n\r\n    deleteLiteral(literalIndex: number) {\r\n        this.literals.splice(literalIndex, 1);\r\n        return this;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\nexport enum QAFollowingOperator {\r\n    OR = \"||\",\r\n    AND = \"&\"\r\n}"]},"metadata":{},"sourceType":"module"}