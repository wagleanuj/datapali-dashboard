{"ast":null,"code":"import _ from \"lodash\";\n\nfunction getOptionValueString(opt) {}\n\nexport class AnswerOptions {\n  constructor() {\n    this.optionsMap = {};\n    this.optionGroupMap = {};\n    this.options = [];\n    this.opt_count = 0;\n    this.group_count = 0;\n  }\n\n  get SortedOptions() {\n    let grouplessOptions = Object.values(this.optionsMap).filter(item => !item.groupName);\n    let groups = Object.values(this.optionGroupMap);\n    return {\n      groups: groups,\n      rootOptions: grouplessOptions\n    };\n  }\n\n  addOption(option, groupname) {\n    if (!option) {\n      option = {\n        id: 'opt-' + this.opt_count,\n        value: undefined,\n        groupName: groupname\n      };\n    }\n\n    this.optionsMap[option.id] = option;\n\n    if (groupname) {\n      let group = this.optionGroupMap[groupname];\n\n      if (!group) {\n        group = {\n          id: \"opt-grp-\" + this.group_count,\n          name: groupname,\n          appearingCondition: undefined,\n          members: [option]\n        };\n        this.optionGroupMap[groupname] = group;\n        this.group_count++;\n      }\n\n      this.options.push(group);\n    } else {\n      this.options.push(option);\n    }\n\n    this.opt_count++;\n    return this;\n  }\n\n  addGroup(groupname) {\n    let group = {\n      id: \"opt-grp\" + this.group_count,\n      name: groupname || \"group-\".concat(this.group_count),\n      appearingCondition: undefined,\n      members: []\n    };\n    this.optionGroupMap[group.name] = group;\n    this.options.push(group);\n    this.group_count++;\n    return group;\n  }\n\n  setValueForOption(id, newValue) {\n    let option = this.optionsMap[id];\n\n    if (option) {\n      option.value = newValue;\n    }\n\n    return this;\n  }\n\n  deleteOption(id) {\n    let opt = this.optionsMap[id];\n\n    if (opt) {\n      delete this.optionsMap[id];\n      let groupname = opt.groupName;\n\n      if (groupname) {\n        let group = this.optionGroupMap[groupname];\n\n        if (group) {\n          let ind = group.members.findIndex(item => item.id === id);\n\n          if (ind > -1) {\n            group.members.splice(ind, 1);\n          }\n        }\n      }\n    }\n\n    return this;\n  }\n\n  assignOptionToGroup(optionIds, groupName) {\n    let existingGroup = this.optionGroupMap[groupName];\n\n    if (!existingGroup) {\n      existingGroup = this.addGroup(groupName);\n      this.optionGroupMap[existingGroup.name] = existingGroup;\n    }\n\n    for (let i = 0; i < optionIds.length; i++) {\n      let optionId = optionIds[i];\n      let option = this.optionsMap[optionId];\n      let option_group = option.groupName && this.optionGroupMap[option.groupName];\n      if (existingGroup.members.find(item => item.id === optionId)) continue; //unassign from the group the option is in \n\n      if (option_group) {\n        let find = option_group.members.findIndex(item => item.id === option.id);\n\n        if (find > -1) {\n          option_group.members.splice(find, 1);\n        }\n      }\n\n      option.groupName = existingGroup.name;\n      existingGroup.members.push(option);\n    }\n\n    return this;\n  }\n\n  setConditionForOption(optionId, condition) {\n    let option = this.optionsMap[optionId];\n    if (option) option.appearingCondition = condition;\n    return this;\n  }\n\n  setConditionForGroup(groupname, condition) {\n    let group = this.optionGroupMap[groupname];\n    if (group) group.appearingCondition = condition;\n    return this;\n  }\n\n  unassignGroup(ids) {\n    ids.forEach(id => {\n      let option = this.optionsMap[id];\n      let opt_groupname = option.groupName;\n\n      if (option && opt_groupname) {\n        let optgroup = this.optionGroupMap[opt_groupname];\n\n        if (optgroup) {\n          let ind = optgroup.members.findIndex(item => item.id === id);\n          optgroup.members.splice(ind, 1);\n        }\n      }\n\n      if (option) {\n        option.groupName = undefined;\n      }\n    });\n  }\n\n  changeGroupName(oldname, newname) {\n    let group = this.optionGroupMap[oldname];\n    let members_ids = group.members.map(item => item.id);\n\n    if (members_ids) {\n      members_ids.forEach(id => {\n        let option = this.optionsMap[id];\n        if (option) option.groupName = newname;\n      });\n    }\n\n    if (group) {\n      group.name = newname;\n\n      let newGroup = _.clone(group);\n\n      delete this.optionGroupMap[oldname];\n      this.optionGroupMap[newname] = newGroup;\n    }\n  }\n\n  deleteGroup(name) {\n    let group = this.optionGroupMap[name];\n    if (!group) return this;\n    let members_ids = group.members.map(item => item.id);\n\n    if (members_ids) {\n      members_ids.forEach(id => {\n        let option = this.optionsMap[id];\n        if (option) option.groupName = undefined;\n      });\n    }\n\n    delete this.optionGroupMap[name];\n  }\n\n  setOptionTypeFor(optionId, newType) {\n    let opt = this.optionsMap[optionId];\n\n    if (opt) {\n      opt.type = newType;\n      opt.value = undefined;\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/anujwagle/Desktop/temp/datapali-dashboard/src/components/AnswerOptions.tsx"],"names":["_","getOptionValueString","opt","AnswerOptions","constructor","optionsMap","optionGroupMap","options","opt_count","group_count","SortedOptions","grouplessOptions","Object","values","filter","item","groupName","groups","rootOptions","addOption","option","groupname","id","value","undefined","group","name","appearingCondition","members","push","addGroup","setValueForOption","newValue","deleteOption","ind","findIndex","splice","assignOptionToGroup","optionIds","existingGroup","i","length","optionId","option_group","find","setConditionForOption","condition","setConditionForGroup","unassignGroup","ids","forEach","opt_groupname","optgroup","changeGroupName","oldname","newname","members_ids","map","newGroup","clone","deleteGroup","setOptionTypeFor","newType","type"],"mappings":"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","sourcesContent":["import { QACondition } from \"../form/condition\";\nimport { QAValueType } from \"./AnswerType\";\nimport _ from \"lodash\";\nexport interface QAOption {\n    appearingCondition?: QACondition;\n    type?: QAValueType;\n    id: string,\n    value?: string\n    groupName?: string\n}\n\nfunction getOptionValueString(opt: QAOption) {\n\n}\n\nexport interface QAOptionGroup {\n    id: string,\n    name: string,\n    appearingCondition?: QACondition,\n    members: QAOption[],\n\n}\nexport class AnswerOptions {\n    optionsMap: {\n        [key: string]: QAOption;\n    } = {};\n    optionGroupMap: {\n        [key: string]: QAOptionGroup;\n    } = {};\n    options: (QAOption | QAOptionGroup)[] = [];\n    private opt_count: number = 0;\n    private group_count: number = 0;\n    constructor() {\n    }\n    get SortedOptions() {\n        let grouplessOptions = Object.values(this.optionsMap).filter(item => !item.groupName);\n        let groups = Object.values(this.optionGroupMap);\n        return {\n            groups: groups,\n            rootOptions: grouplessOptions\n        };\n    }\n    addOption(option?: QAOption, groupname?: string) {\n        if (!option) {\n            option = { id: 'opt-' + this.opt_count, value: undefined, groupName: groupname };\n        }\n        this.optionsMap[option.id] = option;\n        if (groupname) {\n            let group: QAOptionGroup = this.optionGroupMap[groupname];\n            if (!group) {\n                group = { id: \"opt-grp-\" + this.group_count, name: groupname, appearingCondition: undefined, members: [option] };\n                this.optionGroupMap[groupname] = group;\n                this.group_count++;\n            }\n            this.options.push(group);\n        }\n        else {\n            this.options.push(option);\n        }\n        this.opt_count++;\n        return this;\n    }\n    addGroup(groupname?: string) {\n        let group: QAOptionGroup = { id: \"opt-grp\" + this.group_count, name: groupname || `group-${this.group_count}`, appearingCondition: undefined, members: [] };\n        this.optionGroupMap[group.name] = group;\n        this.options.push(group);\n        this.group_count++;\n        return group;\n    }\n\n    setValueForOption(id: string, newValue: string) {\n        let option = this.optionsMap[id];\n        if (option) {\n            option.value = newValue;\n        }\n        return this;\n    }\n\n    deleteOption(id: string) {\n        let opt = this.optionsMap[id];\n        if (opt) {\n            delete this.optionsMap[id];\n            let groupname = opt.groupName;\n            if (groupname) {\n                let group = this.optionGroupMap[groupname];\n                if (group) {\n                    let ind = group.members.findIndex(item => item.id === id);\n                    if (ind > -1) {\n                        group.members.splice(ind, 1);\n                    }\n                }\n            }\n        }\n        return this;\n    }\n    assignOptionToGroup(optionIds: string[], groupName: string) {\n        let existingGroup = this.optionGroupMap[groupName];\n        if (!existingGroup) {\n            existingGroup = this.addGroup(groupName);\n            this.optionGroupMap[existingGroup.name] = existingGroup;\n        }\n        for (let i = 0; i < optionIds.length; i++) {\n            let optionId = optionIds[i];\n            let option = this.optionsMap[optionId];\n            let option_group = option.groupName && this.optionGroupMap[option.groupName];\n            if (existingGroup.members.find(item => item.id === optionId))\n                continue;\n            //unassign from the group the option is in \n            if (option_group) {\n                let find = option_group.members.findIndex(item => item.id === option.id);\n                if (find > -1) {\n                    option_group.members.splice(find, 1);\n                }\n            }\n            option.groupName = existingGroup.name;\n            existingGroup.members.push(option);\n        }\n        return this;\n    }\n    setConditionForOption(optionId: string, condition: QACondition) {\n        let option = this.optionsMap[optionId];\n        if (option)\n            option.appearingCondition = condition;\n        return this;\n    }\n    setConditionForGroup(groupname: string, condition: QACondition) {\n        let group = this.optionGroupMap[groupname];\n        if (group)\n            group.appearingCondition = condition;\n        return this;\n    }\n    unassignGroup(ids: string[]) {\n        ids.forEach(id => {\n            let option = this.optionsMap[id];\n            let opt_groupname = option.groupName;\n            if (option && opt_groupname) {\n                let optgroup = this.optionGroupMap[opt_groupname];\n                if (optgroup) {\n                    let ind = optgroup.members.findIndex(item => item.id === id);\n                    optgroup.members.splice(ind, 1);\n                }\n            }\n            if (option) {\n                option.groupName = undefined;\n            }\n        });\n    }\n    changeGroupName(oldname: string, newname: string) {\n        let group = this.optionGroupMap[oldname];\n        let members_ids = group.members.map(item => item.id);\n        if (members_ids) {\n            members_ids.forEach(id => {\n                let option = this.optionsMap[id];\n                if (option)\n                    option.groupName = newname;\n            });\n        }\n        if (group) {\n            group.name = newname;\n            let newGroup = _.clone(group);\n            delete this.optionGroupMap[oldname];\n            this.optionGroupMap[newname] = newGroup;\n        }\n    }\n    deleteGroup(name: string) {\n        let group = this.optionGroupMap[name];\n        if (!group)\n            return this;\n        let members_ids = group.members.map(item => item.id);\n        if (members_ids) {\n            members_ids.forEach(id => {\n                let option = this.optionsMap[id];\n                if (option)\n                    option.groupName = undefined;\n            });\n        }\n        delete this.optionGroupMap[name];\n    }\n    setOptionTypeFor(optionId: string, newType: QAValueType) {\n        let opt = this.optionsMap[optionId];\n        if (opt) {\n            opt.type = newType;\n            opt.value = undefined;\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}