{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Boundary } from \"@blueprintjs/core\";\nimport { areSameDay } from \"./common/dateUtils\";\n\nvar DateRangeSelectionStrategy =\n/** @class */\nfunction () {\n  function DateRangeSelectionStrategy() {}\n  /**\n   * Returns the new date-range and the boundary that would be affected if `day` were clicked. The\n   * affected boundary may be different from the provided `boundary` in some cases. For example,\n   * clicking a particular boundary's selected date will always deselect it regardless of which\n   * `boundary` you provide to this function (because it's simply a more intuitive interaction).\n   */\n\n\n  DateRangeSelectionStrategy.getNextState = function (currentRange, day, allowSingleDayRange, boundary) {\n    if (boundary != null) {\n      return this.getNextStateForBoundary(currentRange, day, allowSingleDayRange, boundary);\n    } else {\n      return this.getDefaultNextState(currentRange, day, allowSingleDayRange);\n    }\n  };\n\n  DateRangeSelectionStrategy.getNextStateForBoundary = function (currentRange, day, allowSingleDayRange, boundary) {\n    var boundaryDate = this.getBoundaryDate(boundary, currentRange);\n    var otherBoundary = this.getOtherBoundary(boundary);\n    var otherBoundaryDate = this.getBoundaryDate(otherBoundary, currentRange);\n    var nextBoundary;\n    var nextDateRange;\n\n    if (boundaryDate == null && otherBoundaryDate == null) {\n      nextBoundary = boundary;\n      nextDateRange = this.createRangeForBoundary(boundary, day, null);\n    } else if (boundaryDate != null && otherBoundaryDate == null) {\n      var nextBoundaryDate = areSameDay(boundaryDate, day) ? null : day;\n      nextBoundary = boundary;\n      nextDateRange = this.createRangeForBoundary(boundary, nextBoundaryDate, null);\n    } else if (boundaryDate == null && otherBoundaryDate != null) {\n      if (areSameDay(day, otherBoundaryDate)) {\n        var nextDate = void 0;\n\n        if (allowSingleDayRange) {\n          nextBoundary = boundary;\n          nextDate = otherBoundaryDate;\n        } else {\n          nextBoundary = otherBoundary;\n          nextDate = null;\n        }\n\n        nextDateRange = this.createRangeForBoundary(boundary, nextDate, nextDate);\n      } else if (this.isOverlappingOtherBoundary(boundary, day, otherBoundaryDate)) {\n        nextBoundary = otherBoundary;\n        nextDateRange = this.createRangeForBoundary(boundary, otherBoundaryDate, day);\n      } else {\n        nextBoundary = boundary;\n        nextDateRange = this.createRangeForBoundary(boundary, day, otherBoundaryDate);\n      }\n    } else {\n      // both boundaryDate and otherBoundaryDate are already defined\n      if (areSameDay(boundaryDate, day)) {\n        var isSingleDayRangeSelected = areSameDay(boundaryDate, otherBoundaryDate);\n        var nextOtherBoundaryDate = isSingleDayRangeSelected ? null : otherBoundaryDate;\n        nextBoundary = boundary;\n        nextDateRange = this.createRangeForBoundary(boundary, null, nextOtherBoundaryDate);\n      } else if (areSameDay(day, otherBoundaryDate)) {\n        var _a = allowSingleDayRange ? [otherBoundaryDate, otherBoundaryDate] : [boundaryDate, null],\n            nextBoundaryDate = _a[0],\n            nextOtherBoundaryDate = _a[1];\n\n        nextBoundary = allowSingleDayRange ? boundary : otherBoundary;\n        nextDateRange = this.createRangeForBoundary(boundary, nextBoundaryDate, nextOtherBoundaryDate);\n      } else if (this.isOverlappingOtherBoundary(boundary, day, otherBoundaryDate)) {\n        nextBoundary = boundary;\n        nextDateRange = this.createRangeForBoundary(boundary, day, null);\n      } else {\n        // extend the date range with an earlier boundaryDate date\n        nextBoundary = boundary;\n        nextDateRange = this.createRangeForBoundary(boundary, day, otherBoundaryDate);\n      }\n    }\n\n    return {\n      dateRange: nextDateRange,\n      boundary: nextBoundary\n    };\n  };\n\n  DateRangeSelectionStrategy.getDefaultNextState = function (selectedRange, day, allowSingleDayRange) {\n    var start = selectedRange[0],\n        end = selectedRange[1];\n    var nextDateRange;\n\n    if (start == null && end == null) {\n      nextDateRange = [day, null];\n    } else if (start != null && end == null) {\n      nextDateRange = this.createRange(day, start, allowSingleDayRange);\n    } else if (start == null && end != null) {\n      nextDateRange = this.createRange(day, end, allowSingleDayRange);\n    } else {\n      var isStart = areSameDay(start, day);\n      var isEnd = areSameDay(end, day);\n\n      if (isStart && isEnd) {\n        nextDateRange = [null, null];\n      } else if (isStart) {\n        nextDateRange = [null, end];\n      } else if (isEnd) {\n        nextDateRange = [start, null];\n      } else {\n        nextDateRange = [day, null];\n      }\n    }\n\n    return {\n      dateRange: nextDateRange\n    };\n  };\n\n  DateRangeSelectionStrategy.getOtherBoundary = function (boundary) {\n    return boundary === Boundary.START ? Boundary.END : Boundary.START;\n  };\n\n  DateRangeSelectionStrategy.getBoundaryDate = function (boundary, dateRange) {\n    return boundary === Boundary.START ? dateRange[0] : dateRange[1];\n  };\n\n  DateRangeSelectionStrategy.isOverlappingOtherBoundary = function (boundary, boundaryDate, otherBoundaryDate) {\n    return boundary === Boundary.START ? boundaryDate > otherBoundaryDate : boundaryDate < otherBoundaryDate;\n  };\n\n  DateRangeSelectionStrategy.createRangeForBoundary = function (boundary, boundaryDate, otherBoundaryDate) {\n    return boundary === Boundary.START ? [boundaryDate, otherBoundaryDate] : [otherBoundaryDate, boundaryDate];\n  };\n\n  DateRangeSelectionStrategy.createRange = function (a, b, allowSingleDayRange) {\n    // clicking the same date again will clear it\n    if (!allowSingleDayRange && areSameDay(a, b)) {\n      return [null, null];\n    }\n\n    return a < b ? [a, b] : [b, a];\n  };\n\n  return DateRangeSelectionStrategy;\n}();\n\nexport { DateRangeSelectionStrategy };","map":null,"metadata":{},"sourceType":"module"}